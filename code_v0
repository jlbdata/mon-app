import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Users, Info, TrendingUp } from 'lucide-react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, BarChart, Bar } from 'recharts';

const FootballRadarApp = () => {
  const [players, setPlayers] = useState([]);
  const [selectedPlayer, setSelectedPlayer] = useState(null);
  const [uploadStatus, setUploadStatus] = useState('');
  const [showTooltip, setShowTooltip] = useState(null);
  const [csvUrl, setCsvUrl] = useState('https://raw.githubusercontent.com/jlbdata/data/main/compare_joueur.csv');
  const [isLoading, setIsLoading] = useState(false);
  const [selectedSeason, setSelectedSeason] = useState('');
  const [selectedChampionship, setSelectedChampionship] = useState('');
  const [selectedTeam, setSelectedTeam] = useState('');
  const [selectedPoste, setSelectedPoste] = useState('');
  const [selectedProfil, setSelectedProfil] = useState('');
  const [minMinutes, setMinMinutes] = useState(0);
  const [seasons, setSeasons] = useState([]);
  const [championships, setChampionships] = useState([]);
  const [teams, setTeams] = useState([]);
  const [postesAgreges, setPostesAgreges] = useState([]);
  const [profilsDetectes, setProfilsDetectes] = useState([]);
  const [filteredPlayers, setFilteredPlayers] = useState([]);
  const [showTopPlayers, setShowTopPlayers] = useState(false);
  const [topPlayersCount, setTopPlayersCount] = useState(10);
  const [showEvolution, setShowEvolution] = useState(false);
  const [evolutionStats, setEvolutionStats] = useState([]);
  const [showCareerRanking, setShowCareerRanking] = useState(false);
  const [careerRankingData, setCareerRankingData] = useState([]);
  const [expandedChart, setExpandedChart] = useState(null);
  const [showSeasonFilter, setShowSeasonFilter] = useState(false);
  const [seasonFilters, setSeasonFilters] = useState({
    minNote: 6.0,
    maxNote: 10.0,
    selectedSeasons: [],
    selectedPoste: '',
    minMinutes: 0,
    minValeurMarchande: 0,
    maxValeurMarchande: 200
  });
  const [comparePlayer, setComparePlayer] = useState(null);
  const [evolutionStatsCompare, setEvolutionStatsCompare] = useState([]);
  const [compareSearchTerm, setCompareSearchTerm] = useState('');
  const [showCompareDropdown, setShowCompareDropdown] = useState(false);
  const [playerSearchTerm, setPlayerSearchTerm] = useState('');
  const [showPlayerDropdown, setShowPlayerDropdown] = useState(false);
  const [showRadarComparison, setShowRadarComparison] = useState(false);
  const canvasRef = useRef(null);
  const radarComparisonRef = useRef(null);
  const [showBestTeam, setShowBestTeam] = useState(false);
  const [selectedFormation, setSelectedFormation] = useState('4-3-3');
  const [bestTeam, setBestTeam] = useState([]);
  const [showFieldView, setShowFieldView] = useState(false);
  const fieldCanvasRef = useRef(null);
  const [showSimilarPlayers, setShowSimilarPlayers] = useState(false);
  const [similarPlayers, setSimilarPlayers] = useState([]);

  // Mapping des postes
  const posteMap = {
    "LCB": "D√©fenseur axial gauche",
    "RCB": "D√©fenseur axial droit",
    "CB": "D√©fenseur axial gauche",
    "LB": "Arri√®re lat√©ral gauche",
    "LWB": "Arri√®re lat√©ral gauche",
    "RB": "Arri√®re lat√©ral droit",
    "RWB": "Arri√®re lat√©ral droit",
    "DMF": "Milieu d√©fensif",
    "LDMF": "Milieu d√©fensif",
    "RDMF": "Milieu d√©fensif",
    "DMC": "Milieu d√©fensif",
    "LCMF": "Milieu offensif",
    "RCMF": "Milieu offensif",
    "AMF": "Milieu offensif",
    "LAMF": "Milieu offensif",
    "RAMF": "Milieu offensif",
    "LW": "Ailier gauche",
    "LWF": "Ailier gauche",
    "RW": "Ailier droit",
    "RWF": "Ailier droit",
    "CF": "Attaquant"
  };

  // Liste fixe des postes agr√©g√©s possibles dans l'ordre d√©fense -> attaque
  const postesAgregesPossibles = [
    "Arri√®re lat√©ral gauche",
    "D√©fenseur axial gauche",
    "D√©fenseur axial droit",
    "Arri√®re lat√©ral droit",
    "Milieu d√©fensif",
    "Milieu offensif",
    "Ailier gauche",
    "Ailier droit",
    "Attaquant"
  ];

  // Fonction pour obtenir le poste agr√©g√© avec v√©rification de cha√Æne de caract√®res
  const getPosteAgrege = (poste) => {
    if (!poste) return 'Non d√©fini';
    
    // Convertir en string et nettoyer les espaces
    const posteStr = String(poste).trim().toUpperCase();
    
    // V√©rifier chaque type de poste par extraction de cha√Æne
    // D√©fenseurs axiaux (gauche, droit, central)
    if (posteStr.includes('LCB')) return 'D√©fenseur axial gauche';
    if (posteStr.includes('RCB')) return 'D√©fenseur axial droit';
    if (posteStr.includes('CB') && !posteStr.includes('L') && !posteStr.includes('R')) return 'D√©fenseur axial gauche';
    
    if ((posteStr.includes('LB') || posteStr.includes('LWB')) && !posteStr.includes('R')) return 'Arri√®re lat√©ral gauche';
    if (posteStr.includes('RB') || posteStr.includes('RWB')) return 'Arri√®re lat√©ral droit';
    
    if (posteStr.includes('DMF') || posteStr.includes('DMC')) return 'Milieu d√©fensif';
    
    if (posteStr.includes('CMF') || posteStr.includes('AMF') || posteStr.includes('MC')) return 'Milieu offensif';
    
    if ((posteStr.includes('LW') || posteStr.includes('LWF')) && !posteStr.includes('R')) return 'Ailier gauche';
    if (posteStr.includes('RW') || posteStr.includes('RWF')) return 'Ailier droit';
    
    if (posteStr.includes('CF') || posteStr.includes('ST')) return 'Attaquant';
    
    return 'Non d√©fini';
  };

  // Fonction pour obtenir tous les postes agr√©g√©s uniques (uniquement ceux d√©finis)
  const getPostesAgregesUniques = (playersList) => {
    const postesSet = new Set();
    playersList.forEach(p => {
      const posteAgrege = getPosteAgrege(p.Place);
      if (postesAgregesPossibles.includes(posteAgrege)) {
        postesSet.add(posteAgrege);
      }
    });
    // Trier selon l'ordre d√©fini dans postesAgregesPossibles
    return [...postesSet].sort((a, b) => {
      return postesAgregesPossibles.indexOf(a) - postesAgregesPossibles.indexOf(b);
    });
  };

  // Pr√©charger la police Comic Sans MS
  useEffect(() => {
    // Fermer les dropdowns si on clique ailleurs
    const handleClickOutside = (e) => {
      if (!e.target.closest('.compare-dropdown-container')) {
        setShowCompareDropdown(false);
      }
      if (!e.target.closest('.player-dropdown-container')) {
        setShowPlayerDropdown(false);
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  useEffect(() => {
    const loadFont = async () => {
      try {
        // V√©rifier si on est sur desktop ou mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        if (!isMobile) {
          // Forcer le chargement de Comic Sans MS sur desktop uniquement
          await document.fonts.load("12px 'Comic Sans MS'");
          await document.fonts.load("bold 12px 'Comic Sans MS'");
          console.log('Police Comic Sans MS charg√©e');
        } else {
          console.log('Mode mobile d√©tect√©, utilisation de la police syst√®me');
        }
      } catch (error) {
        console.error('Erreur chargement police:', error);
      }
    };
    loadFont();
  }, []);

  const exampleData = [
    {
      Joueur: "L. Messi",
      √âquipe: "Inter Miami",
      Saison: "2024/2025",
      Championnat: "MLS",
      Place: "Ailier droit",
      √Çge: 37,
      "Valeur.marchande": 35000000,
      "Contrat.expiration": "2025",
      "Minutes.jou√©es": 2430,
      note: 8.5,
      "Buts.par.90.min": 0.8,
      "Expected.Goal": 0.75,
      "Passes.d√©cisives.par.90.min": 0.6,
      "Expected.Pass.D": 0.55,
      "R√©alisations.en.profondeur.par.90": 3.2,
      "Passes.surface.r√©paration": 4.5,
      "Tirs.cadr√©s": 65,
      "Duels.offensifs.par.90.min": 8.5,
      "Duels.offensifs.r√©ussis": 62,
      "Duels.defensifs.par.90.min": 3.2,
      "Duels.defensifs.r√©ussis": 55,
      "Duels.a√©riens.par.90.min": 1.5,
      "Duels.a√©riens.r√©ussis": 48,
      "Passes.r√©ussies": 88,
      "Centres.r√©ussis": 2.8,
      "Courses.progressives.par.90.min": 5.6,
      "Interceptions..sur.90.min": 1.2,
      "Dribbles.par.90.min": 6.8,
      "Dribbles.r√©ussis": 72,
      "Fautes.par.90.min": 1.8,
      "Touches.de.balle.dans.la.surface.de.r√©paration.sur.90.min": 8.5,
      "Buts.de.la.t√™te.sur.90.min": 0.1,
      "Lng.passes.par.90": 3.4,
      "Passes.der.tiers.r√©ussies": 4.2,
      "PCT_Passes.avant": 45,
      "PCT_Passes.arri√®re": 30,
      "PCT_Passes.lat√©rales": 25,
      "PCT_Passes.r√©ussies": 88,
      "vingtile_Buts.par.90.min": 18,
      "vingtile_Expected.Goal": 17,
      "vingtile_Passes.d√©cisives.par.90.min": 19,
      "vingtile_Expected.Pass.D": 18,
      "vingtile_R√©alisations.en.profondeur.par.90": 16,
      "vingtile_Passes.surface.r√©paration": 19,
      "vingtile_Tirs.cadr√©s": 17,
      "vingtile_Duels.offensifs.par.90.min": 16,
      "vingtile_Duels.offensifs.r√©ussis": 15,
      "vingtile_Duels.defensifs.par.90.min": 8,
      "vingtile_Duels.defensifs.r√©ussis": 10,
      "vingtile_Duels.a√©riens.par.90.min": 6,
      "vingtile_Duels.a√©riens.r√©ussis": 8,
      "vingtile_Passes.r√©ussies": 18,
      "vingtile_Centres.r√©ussis": 14,
      "vingtile_Courses.progressives.par.90.min": 15,
      "vingtile_Interceptions..sur.90.min": 7,
      "vingtile_Dribbles.par.90.min": 19,
      "vingtile_Dribbles.r√©ussis": 19,
      "vingtile_Fautes.par.90.min": 12,
      "vingtile_Touches.de.balle.dans.la.surface.de.r√©paration.sur.90.min": 18,
      "vingtile_Buts.de.la.t√™te.sur.90.min": 4,
      "vingtile_Lng.passes.par.90": 14,
      "vingtile_Passes.der.tiers.r√©ussies": 16,
      "vingtile_PCT_Passes.avant": 14,
      "vingtile_PCT_Passes.arri√®re": 12,
      "vingtile_PCT_Passes.lat√©rales": 11,
      "vingtile_PCT_Passes.r√©ussies": 17
    }
  ];

  // R√®gles de for√ßage pour certains joueurs
  const forcedPositions = {
    'M. Greenwood': 'Ailier droit',
    'K. Kvaratskhelia': 'Ailier gauche',
    'Kvaratskhelia': 'Ailier gauche'
  };

  // Mapping strict entre profils d√©tect√©s et postes agr√©g√©s
  // Bas√© sur le code R : profiles_detailles_v2_simplifie (18 profils)
  const profilToPosteMap = {
    // ‚ïê‚ïê‚ïê D√âFENSEURS CENTRAUX (4 profils) ‚ïê‚ïê‚ïê
    'D√©fenseur central stoppeur': 'D√©fenseur axial',
    'D√©fenseur central relanceur': 'D√©fenseur axial',
    'D√©fenseur central couvreur': 'D√©fenseur axial',
    'D√©fenseur central hybride': 'D√©fenseur axial',
    
    // ‚ïê‚ïê‚ïê LAT√âRAUX (3 profils) ‚ïê‚ïê‚ïê
    'Lat√©ral d√©fensif': 'Arri√®re lat√©ral',
    'Lat√©ral offensif/moderne': 'Arri√®re lat√©ral',
    'Piston (Wing-back)': 'Arri√®re lat√©ral',
    
    // ‚ïê‚ïê‚ïê MILIEUX D√âFENSIFS (4 profils) ‚ïê‚ïê‚ïê
    'Sentinelle (6 positionnel)': 'Milieu d√©fensif',
    'Milieu r√©cup√©rateur (Ball-winner)': 'Milieu d√©fensif',
    'Regista': 'Milieu d√©fensif', // ‚ö†Ô∏è Regista = milieu d√©fensif selon le code R
    'Milieu d√©fensif hybride (6-8)': 'Milieu d√©fensif',
    
    // ‚ïê‚ïê‚ïê MILIEUX CENTRAUX/OFFENSIFS (4 profils) ‚ïê‚ïê‚ïê
    'Box-to-box (relayeur)': 'Milieu offensif', // Box-to-box = milieu offensif
    'Meneur de jeu avanc√© (10)': 'Milieu offensif',
    'Milieu offensif travailleur': 'Milieu offensif',
    'Milieu offensif cr√©ateur': 'Milieu offensif',
    
    // ‚ïê‚ïê‚ïê AILIERS ET ATTAQUANTS (3 profils) ‚ïê‚ïê‚ïê
    'Ailier pur (Winger)': 'Ailier',
    'Ailier int√©rieur/invers√©': 'Ailier',
    'Attaquant pivot (Target man)': 'Attaquant',
    'Attaquant complet/Faux 9': 'Attaquant',
    
    // ‚ïê‚ïê‚ïê Anciens profils (pour compatibilit√©) ‚ïê‚ïê‚ïê
    'Finisseur': 'Attaquant',
    'Avant-centre complet': 'Attaquant',
    'Buteur': 'Attaquant',
    'Milieu cr√©atif': 'Milieu offensif',
    'Milieu box-to-box': 'Milieu offensif',
    'Playmaker': 'Milieu offensif',
    'Meneur de jeu': 'Milieu offensif',
    'Sentinelle': 'Milieu d√©fensif',
    'Milieu r√©cup√©rateur': 'Milieu d√©fensif',
    'Milieu d√©fensif': 'Milieu d√©fensif',
    'Ailier cr√©atif': 'Ailier',
    'Ailier dribbleur': 'Ailier',
    'D√©fenseur axial relanceur': 'D√©fenseur axial',
    'D√©fenseur axial physique': 'D√©fenseur axial',
    'Arri√®re lat√©ral offensif': 'Arri√®re lat√©ral',
    'Arri√®re lat√©ral d√©fensif': 'Arri√®re lat√©ral',
    'Piston': 'Arri√®re lat√©ral'
  };
  
  // Fonction pour obtenir le poste agr√©g√© depuis le profil d√©tect√© ET la position
  const getPosteFromProfil = (profil, place, playerName) => {
    // V√©rifier d'abord les r√®gles de for√ßage
    if (playerName && forcedPositions[playerName]) {
      return forcedPositions[playerName];
    }
    
    if (!profil) return null;
    
    // Nettoyer le profil et la position
    const profilClean = profil.trim();
    const placeLower = (place || '').toLowerCase().trim();
    
    // V√©rifier d'abord dans le mapping strict des 18 profils R
    if (profilToPosteMap[profilClean]) {
      let posteFromMap = profilToPosteMap[profilClean];
      
      // Pour les "Ailier" g√©n√©riques, v√©rifier la lat√©ralit√© dans Place
      if (posteFromMap === 'Ailier') {
        if (placeLower.includes('lw') || placeLower.includes('lwf') || placeLower.includes('lamf')) {
          return 'Ailier gauche';
        } else if (placeLower.includes('rw') || placeLower.includes('rwf') || placeLower.includes('ramf')) {
          return 'Ailier droit';
        }
        // Si pas de lat√©ralit√© claire dans Place, chercher dans le profil
        if (profilClean.toLowerCase().includes('gauche')) return 'Ailier gauche';
        if (profilClean.toLowerCase().includes('droit')) return 'Ailier droit';
        return null;
      }
      
      // Pour les "Arri√®re lat√©ral" g√©n√©riques, v√©rifier la lat√©ralit√© dans Place
      if (posteFromMap === 'Arri√®re lat√©ral') {
        if (placeLower.includes('lb') || placeLower.includes('lwb')) {
          return 'Arri√®re lat√©ral gauche';
        } else if (placeLower.includes('rb') || placeLower.includes('rwb')) {
          return 'Arri√®re lat√©ral droit';
        }
        if (profilClean.toLowerCase().includes('gauche')) return 'Arri√®re lat√©ral gauche';
        if (profilClean.toLowerCase().includes('droit')) return 'Arri√®re lat√©ral droit';
        return null;
      }
      
      // Pour les d√©fenseurs axiaux, v√©rifier la lat√©ralit√© dans Place
      if (posteFromMap === 'D√©fenseur axial') {
        if (placeLower.includes('lcb')) return 'D√©fenseur axial gauche';
        if (placeLower.includes('rcb')) return 'D√©fenseur axial droit';
        if (placeLower === 'cb') return 'D√©fenseur axial gauche';
        return null;
      }
      
      // Retourner le poste tel quel depuis le mapping
      return posteFromMap;
    }
    
    // Si pas dans le mapping strict, utiliser l'ancienne logique comme fallback
    const profilLower = profilClean.toLowerCase();
    
    // Attaquants
    if (profilLower.includes('attaquant') || profilLower.includes('avant-centre') || 
        profilLower.includes('finisseur') || profilLower.includes('buteur') ||
        profilLower.includes('pivot') || profilLower.includes('target') ||
        profilLower.includes('faux 9') || profilLower.includes('9 ')) {
      return 'Attaquant';
    }
    
    // Ailiers - v√©rifier AVANT les milieux
    if (profilLower.includes('ailier') || profilLower.includes('winger') || 
        profilLower.includes('invers√©')) {
      if (placeLower.includes('lw') || placeLower.includes('lwf') || placeLower.includes('lamf')) {
        return 'Ailier gauche';
      } else if (placeLower.includes('rw') || placeLower.includes('rwf') || placeLower.includes('ramf')) {
        return 'Ailier droit';
      }
      if (profilLower.includes('gauche')) return 'Ailier gauche';
      if (profilLower.includes('droit')) return 'Ailier droit';
      return null;
    }
    
    // Milieux d√©fensifs - v√©rifier AVANT les milieux offensifs
    if (profilLower.includes('sentinelle') || profilLower.includes('ball-winner') ||
        profilLower.includes('regista') || profilLower.includes('6-8') ||
        profilLower.includes('r√©cup√©rateur') || profilLower.includes('6 position')) {
      return 'Milieu d√©fensif';
    }
    
    // Milieux offensifs
    if (profilLower.includes('box-to-box') || profilLower.includes('relayeur') ||
        profilLower.includes('meneur de jeu avanc√©') || profilLower.includes('10') ||
        profilLower.includes('offensif cr√©ateur') || profilLower.includes('offensif travailleur') ||
        profilLower.includes('playmaker') || profilLower.includes('cr√©atif')) {
      return 'Milieu offensif';
    }
    
    // Milieux g√©n√©riques - regarder d'abord le profil, puis la position
    if (profilLower.includes('milieu')) {
      if (profilLower.includes('d√©fensif')) {
        return 'Milieu d√©fensif';
      }
      if (profilLower.includes('offensif')) {
        return 'Milieu offensif';
      }
      // Si pas de mot-cl√© dans le profil, regarder la position
      if (placeLower.includes('dmf') || placeLower === 'dmc') {
        return 'Milieu d√©fensif';
      }
      // Par d√©faut -> offensif
      return 'Milieu offensif';
    }
    
    // Lat√©raux
    if (profilLower.includes('lat√©ral') || profilLower.includes('piston') || 
        profilLower.includes('wing-back')) {
      if (placeLower.includes('lb') || placeLower.includes('lwb')) {
        return 'Arri√®re lat√©ral gauche';
      } else if (placeLower.includes('rb') || placeLower.includes('rwb')) {
        return 'Arri√®re lat√©ral droit';
      }
      if (profilLower.includes('gauche')) return 'Arri√®re lat√©ral gauche';
      if (profilLower.includes('droit')) return 'Arri√®re lat√©ral droit';
      return null;
    }
    
    // D√©fenseurs axiaux/centraux
    if (profilLower.includes('d√©fenseur') || profilLower.includes('central') ||
        profilLower.includes('stoppeur') || profilLower.includes('couvreur')) {
      if (placeLower.includes('lcb')) {
        return 'D√©fenseur axial gauche';
      } else if (placeLower.includes('rcb')) {
        return 'D√©fenseur axial droit';
      } else if (placeLower === 'cb') {
        return 'D√©fenseur axial gauche';
      }
      return null;
    }
    
    return null;
  };

  useEffect(() => {
    // Filtrer les joueurs selon la saison, le championnat, l'√©quipe, le poste et le profil s√©lectionn√©s
    let filtered = players;
    
    if (selectedSeason) {
      filtered = filtered.filter(p => p.Saison === selectedSeason);
    }
    
    if (selectedChampionship) {
      filtered = filtered.filter(p => p.Championnat === selectedChampionship);
    }
    
    if (selectedTeam) {
      filtered = filtered.filter(p => p.√âquipe === selectedTeam);
    }
    
    if (selectedPoste) {
      // Filtrer par le poste d√©tect√© depuis le profil ET la position
      filtered = filtered.filter(p => getPosteFromProfil(p['Profil_detecte'], p.Place, p.Joueur) === selectedPoste);
    }
    
    if (selectedProfil) {
      filtered = filtered.filter(p => p['Profil_detecte'] === selectedProfil);
    }
    
    // Filtrer par minutes jou√©es
    if (minMinutes > 0) {
      filtered = filtered.filter(p => (p['Minutes.jou√©es'] || 0) >= minMinutes);
    }
    
    setFilteredPlayers(filtered);
    
    // R√©initialiser le joueur s√©lectionn√© si pas dans la liste filtr√©e
    if (selectedPlayer && !filtered.find(p => p.Joueur === selectedPlayer.Joueur && p.Saison === selectedPlayer.Saison)) {
      setSelectedPlayer(filtered[0] || null);
    }
  }, [players, selectedSeason, selectedChampionship, selectedTeam, selectedPoste, selectedProfil, minMinutes]);

  useEffect(() => {
    // Mettre √† jour les championnats disponibles selon la saison
    if (selectedSeason) {
      const championshipsForSeason = [...new Set(
        players.filter(p => p.Saison === selectedSeason).map(p => p.Championnat).filter(Boolean)
      )].sort();
      setChampionships(championshipsForSeason);
      
      // R√©initialiser le championnat si il n'existe pas dans cette saison
      if (selectedChampionship && !championshipsForSeason.includes(selectedChampionship)) {
        setSelectedChampionship('');
      }
    }
  }, [selectedSeason, players]);

  useEffect(() => {
    // Mettre √† jour les √©quipes, postes et profils disponibles selon la saison, le championnat et le poste
    let filteredForTeams = players;
    
    if (selectedSeason) {
      filteredForTeams = filteredForTeams.filter(p => p.Saison === selectedSeason);
    }
    
    if (selectedChampionship) {
      filteredForTeams = filteredForTeams.filter(p => p.Championnat === selectedChampionship);
    }
    
    const teamsFiltered = [...new Set(filteredForTeams.map(p => p.√âquipe).filter(Boolean))].sort();
    setTeams(teamsFiltered);
    
    // Extraire les postes agr√©g√©s depuis les profils d√©tect√©s disponibles
    const postesFromProfils = new Set();
    filteredForTeams.forEach(p => {
      const poste = getPosteFromProfil(p['Profil_detecte'], p.Place, p.Joueur);
      if (poste) {
        postesFromProfils.add(poste);
      }
    });
    
    // Convertir en tableau et trier selon l'ordre d√©fensif -> offensif
    const postesFiltered = [...postesFromProfils].sort((a, b) => {
      return postesAgregesPossibles.indexOf(a) - postesAgregesPossibles.indexOf(b);
    });
    setPostesAgreges(postesFiltered);
    
    // Filtrer aussi par poste pour les profils
    let filteredForProfils = filteredForTeams;
    if (selectedPoste) {
      filteredForProfils = filteredForProfils.filter(p => getPosteFromProfil(p['Profil_detecte'], p.Place, p.Joueur) === selectedPoste);
    }
    
    // Extraire les profils d√©tect√©s uniques en fonction du poste s√©lectionn√©
    const profilsFiltered = [...new Set(
      filteredForProfils
        .map(p => p['Profil_detecte'])
        .filter(Boolean)
    )].sort();
    setProfilsDetectes(profilsFiltered);
    
    // R√©initialiser l'√©quipe si elle n'existe pas dans ce filtre
    if (selectedTeam && !teamsFiltered.includes(selectedTeam)) {
      setSelectedTeam('');
    }
    
    // R√©initialiser le poste si il n'existe pas dans ce filtre
    if (selectedPoste && !postesFiltered.includes(selectedPoste)) {
      setSelectedPoste('');
    }
    
    // R√©initialiser le profil si il n'existe pas dans ce filtre
    if (selectedProfil && !profilsFiltered.includes(selectedProfil)) {
      setSelectedProfil('');
    }
  }, [selectedSeason, selectedChampionship, selectedPoste, players]);

  useEffect(() => {
    // Ne pas charger automatiquement au d√©marrage
    // L'utilisateur devra charger manuellement son fichier
  }, []);

  const calculateEvolution = (playerName) => {
    // Trouver toutes les saisons du joueur
    const playerSeasons = players.filter(p => p.Joueur === playerName).sort((a, b) => {
      const seasonA = a.Saison || '';
      const seasonB = b.Saison || '';
      return seasonA.localeCompare(seasonB);
    });
    
    if (playerSeasons.length <= 1) {
      setEvolutionStats([]);
      return;
    }
    
    // Cr√©er les donn√©es pour le graphique
    const evolutionData = playerSeasons.map(season => ({
      saison: season.Saison,
      championnat: season.Championnat || 'N/A',
      minutes: season['Minutes.jou√©es'] || 0,
      profil: season['Profil_detecte'] || getPosteAgrege(season.Place),
      note: season.note || 0,
      buts: season['Buts.par.90.min'] || 0,
      passesD: season['Passes.d√©cisives.par.90.min'] || 0,
      xG: season['Expected.Goal'] || 0,
      xA: season['Expected.Pass.D'] || 0,
      duelsOff: season['Duels.offensifs.r√©ussis'] || 0,
      duelsDef: season['Duels.defensifs.r√©ussis'] || 0,
      passes: season['Passes.r√©ussies'] || 0,
      dribbles: season['Dribbles.r√©ussis'] || 0
    }));
    
    setEvolutionStats(evolutionData);
  };

  const calculateEvolutionCompare = (playerName) => {
    // Trouver toutes les saisons du joueur
    const playerSeasons = players.filter(p => p.Joueur === playerName).sort((a, b) => {
      const seasonA = a.Saison || '';
      const seasonB = b.Saison || '';
      return seasonA.localeCompare(seasonB);
    });
    
    if (playerSeasons.length === 0) {
      setEvolutionStatsCompare([]);
      return;
    }
    
    // Cr√©er les donn√©es pour le graphique
    const evolutionData = playerSeasons.map(season => ({
      saison: season.Saison,
      championnat: season.Championnat || 'N/A',
      minutes: season['Minutes.jou√©es'] || 0,
      profil: season['Profil_detecte'] || getPosteAgrege(season.Place),
      note: season.note || 0,
      buts: season['Buts.par.90.min'] || 0,
      passesD: season['Passes.d√©cisives.par.90.min'] || 0
    }));
    
    setEvolutionStatsCompare(evolutionData);
  };

  const calculateCareerRanking = () => {
    // Regrouper les joueurs par nom et calculer leur note moyenne pond√©r√©e
    const playerCareerStats = {};
    
    players.forEach(player => {
      const name = player.Joueur;
      if (!name) return;
      
      if (!playerCareerStats[name]) {
        playerCareerStats[name] = {
          name: name,
          totalWeightedNote: 0,
          totalMinutes: 0,
          seasons: [],
          teams: new Set(),
          championships: new Set(),
          postes: new Set(),
          lastAge: null,
          lastSeason: null
        };
      }
      
      const minutes = player['Minutes.jou√©es'] || 0;
      const note = player.note || 0;
      
      playerCareerStats[name].totalWeightedNote += note * minutes;
      playerCareerStats[name].totalMinutes += minutes;
      playerCareerStats[name].seasons.push({
        saison: player.Saison,
        note: note,
        minutes: minutes,
        championnat: player.Championnat
      });
      
      // Garder l'√¢ge et la saison les plus r√©cents
      if (!playerCareerStats[name].lastSeason || player.Saison > playerCareerStats[name].lastSeason) {
        playerCareerStats[name].lastSeason = player.Saison;
        playerCareerStats[name].lastAge = player.√Çge;
      }
      
      if (player.√âquipe) playerCareerStats[name].teams.add(player.√âquipe);
      if (player.Championnat) playerCareerStats[name].championships.add(player.Championnat);
      const poste = getPosteAgrege(player.Place);
      if (poste && poste !== 'Non d√©fini') playerCareerStats[name].postes.add(poste);
    });
    
    // Convertir en tableau et calculer la note moyenne pond√©r√©e
    const rankingData = Object.values(playerCareerStats)
      .map(stats => {
        // Calculer l'√¢ge en 2025/2026
        let age2025 = null;
        if (stats.lastAge && stats.lastSeason) {
          // Extraire l'ann√©e de d√©but de la derni√®re saison (ex: "2024/2025" -> 2024)
          const lastSeasonYear = parseInt(stats.lastSeason.split('/')[0]);
          const yearDiff = 2025 - lastSeasonYear;
          age2025 = stats.lastAge + yearDiff;
        }
        
        return {
          name: stats.name,
          weightedAverage: stats.totalMinutes > 0 ? stats.totalWeightedNote / stats.totalMinutes : 0,
          totalMinutes: stats.totalMinutes,
          seasonsCount: stats.seasons.length,
          seasons: stats.seasons.sort((a, b) => b.saison.localeCompare(a.saison)),
          teams: Array.from(stats.teams).join(', '),
          championships: Array.from(stats.championships).join(', '),
          postes: Array.from(stats.postes).join(', '),
          age2025: age2025
        };
      })
      .filter(p => p.totalMinutes >= minMinutes) // Appliquer le filtre de minutes
      .sort((a, b) => b.weightedAverage - a.weightedAverage);
    
    setCareerRankingData(rankingData);
  };

  useEffect(() => {
    if (showCareerRanking) {
      calculateCareerRanking();
    }
  }, [showCareerRanking, players, minMinutes]);

  useEffect(() => {
    if (selectedPlayer && canvasRef.current) {
      // Attendre que les polices soient charg√©es
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          setTimeout(() => drawRadar(selectedPlayer), 150);
        });
      } else {
        setTimeout(() => drawRadar(selectedPlayer), 150);
      }
    }
    
    // Dessiner le radar de comparaison si activ√©
    if (showRadarComparison && selectedPlayer && comparePlayer && radarComparisonRef.current) {
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          setTimeout(() => drawRadarComparison(), 150);
        });
      } else {
        setTimeout(() => drawRadarComparison(), 150);
      }
    }
    
    // Calculer l'√©volution du joueur sur plusieurs saisons
    if (selectedPlayer) {
      calculateEvolution(selectedPlayer.Joueur);
    }
    
    // Calculer l'√©volution du joueur compar√©
    if (comparePlayer) {
      calculateEvolutionCompare(comparePlayer.Joueur);
    }
  }, [selectedPlayer, comparePlayer, showRadarComparison]);

  const loadCsvFromUrl = async (url) => {
    if (!url.trim()) {
      setUploadStatus('‚ùå Veuillez entrer une URL');
      return;
    }

    setIsLoading(true);
    setUploadStatus('üì° Chargement du fichier...');

    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'text/csv,text/plain,*/*'
        }
      });
      
      if (!response.ok) {
        throw new Error(`Erreur HTTP: ${response.status}`);
      }

      const text = await response.text();
      console.log('CSV charg√©, taille:', text.length, 'caract√®res');
      console.log('Premi√®res lignes:', text.substring(0, 500));
      parseCsvData(text);
    } catch (error) {
      setUploadStatus(`‚ùå Erreur de chargement: ${error.message}`);
      console.error('Erreur compl√®te:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const parseCsvData = (text) => {
    try {
      console.log('D√©but du parsing...');
      const lines = text.split('\n').filter(line => line.trim());
      
      if (lines.length < 2) {
        setUploadStatus('‚ùå Fichier vide ou invalide');
        console.error('Pas assez de lignes:', lines.length);
        return;
      }
      
      // Parser une ligne CSV correctement
      const parseCSVLine = (line) => {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < line.length; i++) {
          const char = line[i];
          const nextChar = line[i + 1];
          
          if (char === '"') {
            if (inQuotes && nextChar === '"') {
              // Guillemet √©chapp√©
              current += '"';
              i++; // Skip next quote
            } else {
              // Toggle quotes
              inQuotes = !inQuotes;
            }
          } else if (char === ',' && !inQuotes) {
            // Fin de champ
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        // Ajouter le dernier champ
        result.push(current);
        return result;
      };
      
      const headers = parseCSVLine(lines[0]);
      console.log('Headers:', headers.length, 'colonnes');
      console.log('Premiers headers:', headers.slice(0, 10));
      
      setUploadStatus(`üìä ${lines.length - 1} lignes trouv√©es, traitement...`);
      
      const data = [];
      let errorCount = 0;
      
      for (let i = 1; i < lines.length; i++) { // Pas de limite sur le nombre de lignes
        try {
          const line = lines[i];
          if (!line.trim()) continue;
          
          const values = parseCSVLine(line);
          
          if (values.length !== headers.length) {
            console.warn(`Ligne ${i}: ${values.length} valeurs vs ${headers.length} headers`);
            errorCount++;
            if (errorCount > 10) continue; // Skip apr√®s trop d'erreurs
          }
          
          const obj = {};
          headers.forEach((header, j) => {
            let val = values[j];
            
            if (val === undefined || val === null) {
              obj[header] = '';
            } else if (val && !isNaN(val) && val.trim() !== '') {
              obj[header] = parseFloat(val);
            } else {
              obj[header] = val;
            }
          });
          
          // V√©rifier que le joueur existe
          if (obj.Joueur && obj.Joueur.trim()) {
            data.push(obj);
          }
        } catch (err) {
          console.error(`Erreur ligne ${i}:`, err);
          errorCount++;
        }
      }
      
      console.log('Parsing termin√©:', data.length, 'joueurs trouv√©s');
      if (data.length > 0) {
        console.log('Premier joueur:', data[0]);
        console.log('Cl√©s disponibles:', Object.keys(data[0]).slice(0, 20));
      }
      
      if (data.length === 0) {
        setUploadStatus('‚ùå Aucun joueur trouv√© dans le fichier');
        return;
      }
      
      // Extraire les saisons et √©quipes uniques
      const uniqueSeasons = [...new Set(data.map(p => p.Saison).filter(Boolean))].sort().reverse();
      const uniqueChampionships = [...new Set(data.map(p => p.Championnat).filter(Boolean))].sort();
      const uniqueTeams = [...new Set(data.map(p => p.√âquipe).filter(Boolean))].sort();
      const uniquePostes = getPostesAgregesUniques(data);
      
      setPlayers(data);
      setSeasons(uniqueSeasons);
      setChampionships(uniqueChampionships);
      setTeams(uniqueTeams);
      setPostesAgreges(uniquePostes);
      setSelectedSeason(uniqueSeasons[0] || '');
      setSelectedChampionship('');
      setSelectedTeam('');
      setSelectedPoste('');
      setSelectedPlayer(null);
      setUploadStatus(`‚úÖ ${data.length} joueur(s) charg√©(s) !`);
      
      setTimeout(() => setUploadStatus(''), 5000);
    } catch (error) {
      setUploadStatus(`‚ùå Erreur parsing: ${error.message}`);
      console.error('Erreur compl√®te:', error);
      console.error('Stack:', error.stack);
    }
  };

  const handleFileUpload = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    setUploadStatus('üìÇ Lecture du fichier...');
    
    const reader = new FileReader();
    reader.onload = (event) => {
      parseCsvData(event.target.result);
    };
    
    reader.onerror = () => {
      setUploadStatus('‚ùå Erreur de lecture du fichier');
    };
    
    reader.readAsText(file, 'UTF-8');
  };

  const stats = [
    { label: "Buts", key: "Buts.par.90.min", vingtile: "vingtile_Buts.par.90.min", category: "Attaque" },
    { label: "Buts t√™te", key: "Buts.de.la.t√™te.sur.90.min", vingtile: "vingtile_Buts.de.la.t√™te.sur.90.min", category: "Attaque" },
    { label: "Ballons\nsurface", key: "Touches.de.balle.dans.la.surface.de.r√©paration.sur.90.min", vingtile: "vingtile_Touches.de.balle.dans.la.surface.de.r√©paration.sur.90.min", category: "Attaque" },
    { label: "Courses\nprog.", key: "Courses.progressives.par.90.min", vingtile: "vingtile_Courses.progressives.par.90.min", category: "Attaque" },
    { label: "Duel off.", key: "Duels.offensifs.par.90.min", vingtile: "vingtile_Duels.offensifs.par.90.min", category: "Attaque" },
    { label: "Duel off.\nR√©ussis", key: "Duels.offensifs.r√©ussis", vingtile: "vingtile_Duels.offensifs.r√©ussis", category: "Attaque" },
    { label: "Tirs cadr.", key: "Tirs.cadr√©s", vingtile: "vingtile_Tirs.cadr√©s", category: "Attaque" },
    { label: "Duels a√©riens", key: "Duels.a√©riens.par.90.min", vingtile: "vingtile_Duels.a√©riens.par.90.min", category: "D√©fense" },
    { label: "Duels a√©riens\nR√©ussis", key: "Duels.a√©riens.r√©ussis", vingtile: "vingtile_Duels.a√©riens.r√©ussis", category: "D√©fense" },
    { label: "Duels d√©f.", key: "Duels.defensifs.par.90.min", vingtile: "vingtile_Duels.defensifs.par.90.min", category: "D√©fense" },
    { label: "Duels d√©f.\nR√©ussis", key: "Duels.defensifs.r√©ussis", vingtile: "vingtile_Duels.defensifs.r√©ussis", category: "D√©fense" },
    { label: "Fautes", key: "Fautes.par.90.min", vingtile: "vingtile_Fautes.par.90.min", category: "D√©fense" },
    { label: "Intercpt.", key: "Interceptions..sur.90.min", vingtile: "vingtile_Interceptions..sur.90.min", category: "D√©fense" },
    { label: "Dribbles", key: "Dribbles.par.90.min", vingtile: "vingtile_Dribbles.par.90.min", category: "Dribble" },
    { label: "Dribbles\nR√©ussis", key: "Dribbles.r√©ussis", vingtile: "vingtile_Dribbles.r√©ussis", category: "Dribble" },
    { label: "% Passe\nArri√®re", key: "PCT_Passes.arri√®re", vingtile: "vingtile_PCT_Passes.arri√®re", category: "Passe" },
    { label: "% Passe\nAvant", key: "PCT_Passes.avant", vingtile: "vingtile_PCT_Passes.avant", category: "Passe" },
    { label: "% Passe\nLat√©rale", key: "PCT_Passes.lat√©rales", vingtile: "vingtile_PCT_Passes.lat√©rales", category: "Passe" },
    { label: "Centres", key: "Centres.r√©ussis", vingtile: "vingtile_Centres.r√©ussis", category: "Passe" },
    { label: "Passe\nLongue", key: "Lng.passes.par.90", vingtile: "vingtile_Lng.passes.par.90", category: "Passe" },
    { label: "Passe\nprog.", key: "R√©alisations.en.profondeur.par.90", vingtile: "vingtile_R√©alisations.en.profondeur.par.90", category: "Passe" },
    { label: "Passe\nsurface", key: "Passes.surface.r√©paration", vingtile: "vingtile_Passes.surface.r√©paration", category: "Passe" },
    { label: "Passe\nTiers", key: "Passes.der.tiers.r√©ussies", vingtile: "vingtile_Passes.der.tiers.r√©ussies", category: "Passe" },
    { label: "Passes", key: "Passes.r√©ussies", vingtile: "vingtile_Passes.r√©ussies", category: "Passe" },
    { label: "Passes\n%", key: "PCT_Passes.r√©ussies", vingtile: "vingtile_PCT_Passes.r√©ussies", category: "Passe" },
    { label: "Passes\nD√©cisives", key: "Passes.d√©cisives.par.90.min", vingtile: "vingtile_Passes.d√©cisives.par.90.min", category: "Passe" },
    { label: "XA", key: "Expected.Pass.D", vingtile: "vingtile_Expected.Pass.D", category: "Passe" },
    { label: "XG", key: "Expected.Goal", vingtile: "vingtile_Expected.Goal", category: "Attaque" }
  ];

  const categoryColors = {
    "Passe": "#3F51B5",
    "Attaque": "#7E57C2",
    "D√©fense": "#BA68C8",
    "Dribble": "#F48FB1"
  };

  const drawRadar = (player) => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // D√©finir la taille en fonction de l'appareil
    const isSmallScreen = window.innerWidth < 768;
    const scale = isSmallScreen ? 2 : 1;
    
    canvas.width = 800 * scale;
    canvas.height = 1400 * scale;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.style.maxWidth = '800px';
    
    // Appliquer le scale au contexte
    ctx.scale(scale, scale);
    
    const width = 800;
    const height = 1400;
    const centerX = width / 2;
    const centerY = height / 2 + 100;
    const maxRadius = Math.min(width, height) / 2.5;

    // Fond
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#010127';
    ctx.fillRect(0, 0, width, height);
    
    // D√©finir une fonction helper pour d√©finir la police
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const setComicFont = (size, weight = 'bold') => {
      if (isMobile) {
        // Sur mobile, utiliser une police syst√®me standard
        ctx.font = `${weight} ${size}px -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif`;
      } else {
        // Sur desktop, utiliser Comic Sans MS
        ctx.font = `${weight} ${size}px Comic Sans MS, Comic Sans, cursive, sans-serif`;
      }
    };

    const numStats = stats.length;
    const angleStep = (2 * Math.PI) / numStats;

    // Cercles guides
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    [0.2, 0.4, 0.6, 0.8, 1].forEach(ratio => {
      ctx.beginPath();
      ctx.arc(centerX, centerY, maxRadius * ratio, 0, 2 * Math.PI);
      ctx.stroke();
    });
    ctx.setLineDash([]);

    const centerRadius = 45;

    // Dessiner barres pizza pour le joueur principal
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      const nextAngle = (i + 1) * angleStep - Math.PI / 2;
      const value = player[stat.vingtile] || 0;
      const barRadius = Math.max((value / 20) * maxRadius, centerRadius);

      // Fond de la tranche
      ctx.fillStyle = '#0a0a2e';
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.arc(centerX, centerY, maxRadius, angle, nextAngle);
      ctx.lineTo(centerX, centerY);
      ctx.closePath();
      ctx.fill();
      
      // Bordure de tranche
      ctx.strokeStyle = 'rgba(121, 121, 121, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Barre de donn√©es avec d√©grad√©
      if (value > 0) {
        const gradient = ctx.createRadialGradient(centerX, centerY, centerRadius, centerX, centerY, barRadius);
        gradient.addColorStop(0, categoryColors[stat.category] + '00');
        gradient.addColorStop(0.3, categoryColors[stat.category]);
        gradient.addColorStop(1, categoryColors[stat.category]);
        
        ctx.fillStyle = gradient;
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.arc(centerX, centerY, barRadius, angle, nextAngle);
        ctx.lineTo(centerX, centerY);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Bordure color√©e
        ctx.strokeStyle = categoryColors[stat.category];
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    });

    // Cercle central
    const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, centerRadius);
    centerGradient.addColorStop(0, '#1a1a4e');
    centerGradient.addColorStop(1, '#010127');
    ctx.fillStyle = centerGradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, centerRadius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Labels et valeurs
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      const value = player[stat.vingtile] || 0;
      
      // Labels EXTERNES (au milieu angulaire de chaque section)
      const labelRadius = maxRadius + 35;
      const labelAngle = angle + angleStep / 2; // Au milieu de la section
      const labelX = centerX + labelRadius * Math.cos(labelAngle);
      const labelY = centerY + labelRadius * Math.sin(labelAngle);
      
      ctx.fillStyle = 'white';
      setComicFont(18);
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      
      const lines = stat.label.split('\n');
      ctx.save();
      setComicFont(18);
      lines.forEach((line, j) => {
        ctx.fillText(line, labelX, labelY + (j - lines.length/2 + 0.5) * 20);
      });
      ctx.restore();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Valeurs √† l'extr√©mit√© des barres
      if (value > 0) {
        const barRadius = Math.max((value / 20) * maxRadius, centerRadius);
        const valueX = centerX + barRadius * Math.cos(angle + angleStep / 2);
        const valueY = centerY + barRadius * Math.sin(angle + angleStep / 2);
        const displayValue = (player[stat.key] || 0).toFixed(2);
        
        ctx.save();
        setComicFont(14);
        const textWidth = ctx.measureText(displayValue).width;
        const padding = 8;
        const boxHeight = 24;
        
        // Ombre de la bo√Æte
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 6;
        ctx.fillStyle = categoryColors[stat.category];
        ctx.fillRect(
          valueX - textWidth/2 - padding, 
          valueY - boxHeight/2, 
          textWidth + padding * 2, 
          boxHeight
        );
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // Bordure de la bo√Æte
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(
          valueX - textWidth/2 - padding, 
          valueY - boxHeight/2, 
          textWidth + padding * 2, 
          boxHeight
        );
        
        ctx.fillStyle = 'white';
        ctx.fillText(displayValue, valueX, valueY);
        ctx.restore();
      }
    });

    // Info joueur sans cadre
    const infoBoxX = 30;
    const infoBoxY = 30;

    ctx.save();
    ctx.textAlign = 'left';
    setComicFont(48);
    ctx.fillStyle = 'white';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 4;
    ctx.fillText(player.Joueur || 'Joueur', infoBoxX + 20, infoBoxY + 60);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.save();
    setComicFont(22);
    const infoLabels = [
      'Championnat:',
      '√âquipe:',
      'Saison:',
      'Poste:',
      'Profil:',
      '√Çge:',
      'Valeur:',
      'Contrat:',
      'Minutes:'
    ];
    
    const infoValues = [
      player.Championnat || 'N/A',
      player.√âquipe || 'N/A',
      player.Saison || 'N/A',
      getPosteFromProfil(player['Profil_detecte'], player.Place) || 'N/A',
      player['Profil_detecte'] || 'N/A',
      `${player.√Çge || 'N/A'} ans`,
      `${((player['Valeur.marchande'] || 0) / 1000000).toFixed(1)}M‚Ç¨`,
      player['Contrat.expiration'] || 'N/A',
      `${player['Minutes.jou√©es'] || 'N/A'} min`
    ];
    
    const labelX = infoBoxX + 20;
    const valueX = infoBoxX + 220;
    
    ctx.textAlign = 'left';
    infoLabels.forEach((label, i) => {
      setComicFont(26);
      ctx.fillText(label, labelX, infoBoxY + 115 + i * 32);
      
      setComicFont(22);
      ctx.fillText(infoValues[i], valueX, infoBoxY + 115 + i * 32);
    });
    ctx.restore();

    // Note globale avec effet 3D
    const noteX = width - 80;
    const noteY = 85;
    const noteRadius = 50;
    
    ctx.save();
    // Ombre de la note
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    const noteGradient = ctx.createRadialGradient(noteX - 10, noteY - 10, 0, noteX, noteY, noteRadius);
    noteGradient.addColorStop(0, '#9575cd');
    noteGradient.addColorStop(1, '#5e35b1');
    ctx.fillStyle = noteGradient;
    ctx.beginPath();
    ctx.arc(noteX, noteY, noteRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // Bordure de la note
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = 'white';
    setComicFont(42);
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 2;
    ctx.fillText((player.note || 0).toFixed(2), noteX, noteY + 4);
    
    setComicFont(12);
    ctx.fillText('NOTE', noteX, noteY + 26);
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();
  };

  const downloadImage = () => {
    if (!canvasRef.current || !selectedPlayer) {
      alert('Aucun joueur s√©lectionn√©');
      return;
    }
    
    try {
      const canvas = canvasRef.current;
      
      // Convertir en blob puis t√©l√©charger
      canvas.toBlob((blob) => {
        if (!blob) {
          alert('Erreur lors de la cr√©ation de l\'image');
          return;
        }
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const playerName = selectedPlayer.Joueur?.replace(/[^a-zA-Z0-9]/g, '_') || 'joueur';
        link.download = `radar_${playerName}.png`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        // Lib√©rer l'URL apr√®s un court d√©lai
        setTimeout(() => URL.revokeObjectURL(url), 100);
      }, 'image/png', 1.0);
    } catch (error) {
      console.error('Erreur lors du t√©l√©chargement:', error);
      alert('Erreur lors du t√©l√©chargement de l\'image');
    }
  };

  const downloadRadarComparison = () => {
    if (!radarComparisonRef.current || !selectedPlayer || !comparePlayer) {
      alert('Veuillez s√©lectionner deux joueurs');
      return;
    }
    
    try {
      const canvas = radarComparisonRef.current;
      
      canvas.toBlob((blob) => {
        if (!blob) {
          alert('Erreur lors de la cr√©ation de l\'image');
          return;
        }
        
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const player1Name = selectedPlayer.Joueur?.replace(/[^a-zA-Z0-9]/g, '_') || 'joueur1';
        const player2Name = comparePlayer.Joueur?.replace(/[^a-zA-Z0-9]/g, '_') || 'joueur2';
        link.download = `radar_comparison_${player1Name}_vs_${player2Name}.png`;
        link.href = url;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        setTimeout(() => URL.revokeObjectURL(url), 100);
      }, 'image/png', 1.0);
    } catch (error) {
      console.error('Erreur lors du t√©l√©chargement:', error);
      alert('Erreur lors du t√©l√©chargement de l\'image');
    }
  };

  // Fonction pour calculer la similarit√© entre deux joueurs
  const calculateSimilarity = (player1, player2) => {
    const note1 = player1.note || 0;
    const note2 = player2.note || 0;
    
    // Diff√©rence absolue de note (non normalis√©e)
    const noteDifference = Math.abs(note1 - note2);
    
    // Si la diff√©rence de note est trop grande (> 0.5), p√©naliser fortement
    // Pour une note entre 5 et 9, 0.5 point c'est significatif
    if (noteDifference > 0.5) {
      // P√©nalit√© exponentielle : plus la diff√©rence est grande, plus le score est mauvais
      return 10 + (noteDifference * 20); // Score tr√®s √©lev√© = mauvaise similarit√©
    }
    
    // Si la note est proche, calculer la similarit√© sur les autres stats
    const statsWithWeights = {
      // Poids tr√®s √©lev√©s pour les duels a√©riens (diff√©rencient les profils physiques)
      'Duels.a√©riens.par.90.min': 4,
      'Duels.a√©riens.r√©ussis': 4,
      
      // Poids √©lev√©s pour les interceptions (diff√©rencient profils d√©fensifs vs offensifs)
      'Interceptions..sur.90.min': 4,
      
      // Poids √©lev√©s pour les buts de t√™te
      'Buts.de.la.t√™te.sur.90.min': 3,
      
      // Poids √©lev√©s pour les stats prioritaires offensives
      'Expected.Goal': 3,
      'Buts.par.90.min': 3,
      'Expected.Pass.D': 3,
      
      // Poids normaux pour toutes les autres stats
      'Passes.d√©cisives.par.90.min': 1,
      'R√©alisations.en.profondeur.par.90': 1,
      'Passes.surface.r√©paration': 1,
      'Tirs.cadr√©s': 1,
      'Duels.offensifs.par.90.min': 1,
      'Duels.offensifs.r√©ussis': 1,
      'Duels.defensifs.par.90.min': 1,
      'Duels.defensifs.r√©ussis': 1,
      'Passes.r√©ussies': 1,
      'Centres.r√©ussis': 1,
      'Courses.progressives.par.90.min': 1,
      'Dribbles.par.90.min': 1,
      'Dribbles.r√©ussis': 1,
      'Fautes.par.90.min': 1,
      'Touches.de.balle.dans.la.surface.de.r√©paration.sur.90.min': 1,
      'Lng.passes.par.90': 1,
      'Passes.der.tiers.r√©ussies': 1,
      'PCT_Passes.avant': 1,
      'PCT_Passes.arri√®re': 1,
      'PCT_Passes.lat√©rales': 1,
      'PCT_Passes.r√©ussies': 1
    };
    
    let totalWeightedDifference = 0;
    let totalWeight = 0;
    
    Object.entries(statsWithWeights).forEach(([stat, weight]) => {
      const val1 = player1[stat] || 0;
      const val2 = player2[stat] || 0;
      
      // Normaliser la diff√©rence par rapport √† la valeur maximale
      const maxVal = Math.max(Math.abs(val1), Math.abs(val2), 0.01);
      const normalizedDiff = Math.abs(val1 - val2) / maxVal;
      
      // Appliquer le poids
      totalWeightedDifference += normalizedDiff * weight;
      totalWeight += weight;
    });
    
    // Calculer le score de similarit√© pond√©r√©
    const statsSimilarityScore = totalWeight > 0 ? totalWeightedDifference / totalWeight : 0;
    
    // Combiner avec la diff√©rence de note (m√™me si petite, elle compte)
    // La diff√©rence de note compte pour 30% du score final
    const finalScore = statsSimilarityScore + (noteDifference * 3);
    
    return finalScore;
  };

  // Fonction pour trouver les joueurs similaires
  const findSimilarPlayers = () => {
    if (!selectedPlayer) return;
    
    // Filtrer les joueurs du m√™me poste
    const playerPoste = getPosteFromProfil(selectedPlayer['Profil_detecte'], selectedPlayer.Place, selectedPlayer.Joueur);
    
    const samePosterPlayers = filteredPlayers.filter(p => {
      // Ne pas inclure le joueur lui-m√™me
      if (p.Joueur === selectedPlayer.Joueur && p.Saison === selectedPlayer.Saison) return false;
      
      // Filtrer par poste similaire
      const poste = getPosteFromProfil(p['Profil_detecte'], p.Place, p.Joueur);
      return poste === playerPoste;
    });
    
    // Calculer la similarit√© pour chaque joueur
    const playersWithSimilarity = samePosterPlayers.map(player => ({
      ...player,
      similarityScore: calculateSimilarity(selectedPlayer, player)
    }));
    
    // Trier par similarit√© (score le plus bas = plus similaire)
    const sortedPlayers = playersWithSimilarity.sort((a, b) => a.similarityScore - b.similarityScore);
    
    // Prendre les 15 plus similaires
    setSimilarPlayers(sortedPlayers.slice(0, 15));
  };

  useEffect(() => {
    if (showSimilarPlayers && selectedPlayer) {
      findSimilarPlayers();
    }
  }, [showSimilarPlayers, selectedPlayer, filteredPlayers]);
  const calculateBestTeam = () => {
    const formations = {
      '4-3-3': {
        'Attaquant': { count: 1, profils: ['Finisseur', 'Avant-centre complet', 'Attaquant polyvalent'] },
        'Ailier gauche': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Attaquant polyvalent'] },
        'Ailier droit': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Attaquant polyvalent'] },
        'Milieu offensif': { count: 2, profils: ['Milieu cr√©atif', 'Milieu box-to-box', 'Milieu relayeur'] },
        'Milieu d√©fensif': { count: 1, profils: ['Milieu d√©fensif', 'Milieu r√©cup√©rateur', 'Milieu box-to-box'] },
        'Arri√®re lat√©ral gauche': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'Arri√®re lat√©ral droit': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'D√©fenseur axial gauche': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial droit': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] }
      },
      '4-4-2': {
        'Attaquant': { count: 2, profils: ['Finisseur', 'Avant-centre complet', 'Attaquant polyvalent'] },
        'Ailier gauche': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Milieu excentr√©'] },
        'Ailier droit': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Milieu excentr√©'] },
        'Milieu offensif': { count: 1, profils: ['Milieu cr√©atif', 'Milieu box-to-box', 'Milieu relayeur'] },
        'Milieu d√©fensif': { count: 1, profils: ['Milieu d√©fensif', 'Milieu r√©cup√©rateur', 'Milieu box-to-box'] },
        'Arri√®re lat√©ral gauche': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'Arri√®re lat√©ral droit': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'D√©fenseur axial gauche': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial droit': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] }
      },
      '3-4-3': {
        'Attaquant': { count: 1, profils: ['Finisseur', 'Avant-centre complet', 'Attaquant polyvalent'] },
        'Ailier gauche': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Attaquant polyvalent'] },
        'Ailier droit': { count: 1, profils: ['Ailier cr√©atif', 'Ailier dribbleur', 'Attaquant polyvalent'] },
        'Milieu offensif': { count: 2, profils: ['Milieu cr√©atif', 'Milieu box-to-box', 'Milieu excentr√©'] },
        'Milieu d√©fensif': { count: 2, profils: ['Milieu d√©fensif', 'Milieu r√©cup√©rateur', 'Milieu box-to-box'] },
        'Arri√®re lat√©ral gauche': { count: 0, profils: [] },
        'Arri√®re lat√©ral droit': { count: 0, profils: [] },
        'D√©fenseur axial gauche': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial droit': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial central': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] }
      },
      '5-3-2': {
        'Attaquant': { count: 2, profils: ['Finisseur', 'Avant-centre complet', 'Attaquant polyvalent'] },
        'Ailier gauche': { count: 0, profils: [] },
        'Ailier droit': { count: 0, profils: [] },
        'Milieu offensif': { count: 2, profils: ['Milieu cr√©atif', 'Milieu box-to-box', 'Milieu relayeur'] },
        'Milieu d√©fensif': { count: 1, profils: ['Milieu d√©fensif', 'Milieu r√©cup√©rateur', 'Milieu box-to-box'] },
        'Arri√®re lat√©ral gauche': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'Arri√®re lat√©ral droit': { count: 1, profils: ['Arri√®re lat√©ral offensif', 'Arri√®re lat√©ral d√©fensif', 'Arri√®re lat√©ral √©quilibr√©'] },
        'D√©fenseur axial gauche': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial droit': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] },
        'D√©fenseur axial central': { count: 1, profils: ['D√©fenseur axial relanceur', 'D√©fenseur axial physique', 'D√©fenseur axial complet'] }
      }
    };

    const formation = formations[selectedFormation];
    const team = [];
    const usedPlayers = new Set(); // Pour √©viter les doublons
    const missingPositions = []; // Pour tracker les postes manquants

    // Pour chaque poste dans la formation
    Object.entries(formation).forEach(([poste, config]) => {
      if (config.count === 0) return;

      // Filtrer les joueurs par poste en utilisant getPosteFromProfil
      let playersAtPosition = filteredPlayers
        .filter(p => {
          const playerPoste = getPosteFromProfil(p['Profil_detecte'], p.Place);
          // Pour les postes "D√©fenseur axial gauche/droit/central", accepter aussi "D√©fenseur axial" g√©n√©rique
          if (poste === 'D√©fenseur axial gauche' || poste === 'D√©fenseur axial droit' || poste === 'D√©fenseur axial central') {
            return playerPoste === poste || playerPoste === 'D√©fenseur axial gauche' || playerPoste === 'D√©fenseur axial droit';
          }
          return playerPoste === poste;
        })
        .filter(p => !usedPlayers.has(p.Joueur)); // √âviter les doublons
      
      // Si des profils sont d√©finis, prioriser les joueurs avec ces profils
      if (config.profils && config.profils.length > 0) {
        // S√©parer les joueurs : ceux avec le bon profil et les autres
        const playersWithProfile = playersAtPosition.filter(p => 
          config.profils.includes(p['Profil_detecte'])
        );
        
        const playersWithoutProfile = playersAtPosition.filter(p => 
          !config.profils.includes(p['Profil_detecte'])
        );
        
        // Trier chaque groupe par note
        playersWithProfile.sort((a, b) => (b.note || 0) - (a.note || 0));
        playersWithoutProfile.sort((a, b) => (b.note || 0) - (a.note || 0));
        
        // Fusionner : d'abord ceux avec profil, puis les autres
        playersAtPosition = [...playersWithProfile, ...playersWithoutProfile];
      } else {
        // Si pas de profils d√©finis, trier simplement par note
        playersAtPosition.sort((a, b) => (b.note || 0) - (a.note || 0));
      }
      
      // V√©rifier si c'est un poste offensif (milieu ou attaque)
      const isOffensivePosition = [
        'Attaquant', 'Ailier gauche', 'Ailier droit', 
        'Milieu offensif', 'Milieu d√©fensif'
      ].includes(poste);
      
      // Prendre les meilleurs joueurs pour ce poste
      let playersAddedForPosition = 0;
      for (let i = 0; i < config.count && i < playersAtPosition.length; i++) {
        const player = playersAtPosition[i];
        const playerNote = player.note || 0;
        
        // R√àGLE GLOBALE : Ne jamais s√©lectionner un joueur avec note < 6.6
        if (playerNote < 6.6) {
          continue; // Passer au joueur suivant
        }
        
        // Si c'est un poste offensif et que la note est < 6.6, chercher un rempla√ßant avec meilleure note
        if (isOffensivePosition && playerNote < 6.8) {
          // Chercher un joueur de remplacement avec note >= 6.8 (ou au moins meilleure que 6.6)
          let replacementFound = false;
          
          for (let j = i + 1; j < playersAtPosition.length; j++) {
            const potentialReplacement = playersAtPosition[j];
            const replacementNote = potentialReplacement.note || 0;
            
            // Si on trouve un joueur avec note >= 6.6 et pas encore utilis√©
            if (replacementNote >= 6.6 && !usedPlayers.has(potentialReplacement.Joueur)) {
              team.push({
                ...potentialReplacement,
                position: poste
              });
              usedPlayers.add(potentialReplacement.Joueur);
              replacementFound = true;
              playersAddedForPosition++;
              break;
            }
          }
          
          // Si aucun rempla√ßant trouv√©, mais le joueur actuel a >= 6.6, le prendre
          if (!replacementFound && playerNote >= 6.6) {
            team.push({
              ...player,
              position: poste
            });
            usedPlayers.add(player.Joueur);
            playersAddedForPosition++;
          }
        } else {
          // Pour les d√©fenseurs ou joueurs avec note >= 6.8, v√©rifier quand m√™me >= 6.6
          if (playerNote >= 6.6) {
            team.push({
              ...player,
              position: poste
            });
            usedPlayers.add(player.Joueur);
            playersAddedForPosition++;
          }
        }
      }
      
      // Si on n'a pas trouv√© assez de joueurs pour ce poste, noter les manquants
      if (playersAddedForPosition < config.count) {
        for (let i = 0; i < config.count - playersAddedForPosition; i++) {
          missingPositions.push({
            poste: poste,
            profils: config.profils,
            isOffensive: isOffensivePosition
          });
        }
      }
    });

    // NE PLUS chercher de rempla√ßants - afficher simplement les postes manquants
    setBestTeam(team);
  };

  useEffect(() => {
    if (showBestTeam) {
      calculateBestTeam();
    }
  }, [showBestTeam, selectedFormation, filteredPlayers]);

  useEffect(() => {
    if (showFieldView && bestTeam.length > 0 && fieldCanvasRef.current) {
      drawField();
    }
  }, [showFieldView, bestTeam, selectedFormation]);

  const drawField = () => {
    const canvas = fieldCanvasRef.current;
    const ctx = canvas.getContext('2d');
    
    const isSmallScreen = window.innerWidth < 768;
    const scale = isSmallScreen ? 2 : 1;
    
    // M√™mes dimensions que le radar pizza
    canvas.width = 800 * scale;
    canvas.height = 1400 * scale;
    
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.style.maxWidth = '800px';
    
    ctx.scale(scale, scale);
    
    const width = 800;
    const height = 1400;
    
    // Fond d√©grad√© du terrain
    const gradient = ctx.createLinearGradient(0, 100, 0, height - 100);
    gradient.addColorStop(0, '#2d5016');
    gradient.addColorStop(0.5, '#3d7018');
    gradient.addColorStop(1, '#2d5016');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 100, width, height - 200);
    
    // Lignes du terrain
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    
    // Ligne de touche
    ctx.strokeRect(50, 150, width - 100, height - 300);
    
    // Ligne m√©diane
    ctx.beginPath();
    ctx.moveTo(50, height / 2);
    ctx.lineTo(width - 50, height / 2);
    ctx.stroke();
    
    // Cercle central
    ctx.beginPath();
    ctx.arc(width / 2, height / 2, 60, 0, 2 * Math.PI);
    ctx.stroke();
    
    // Surface de r√©paration haut
    ctx.strokeRect(width / 2 - 120, 150, 240, 100);
    ctx.strokeRect(width / 2 - 60, 150, 120, 40);
    
    // Surface de r√©paration bas
    ctx.strokeRect(width / 2 - 120, height - 250, 240, 100);
    ctx.strokeRect(width / 2 - 60, height - 190, 120, 40);
    
    // Positions selon formation
          const formations = {
      '4-3-3': [
        // Attaquants
        { x: 0.2, y: 0.15, role: 'Ailier gauche' },
        { x: 0.5, y: 0.1, role: 'Attaquant' },
        { x: 0.8, y: 0.15, role: 'Ailier droit' },
        // Milieux (2 offensifs + 1 d√©fensif)
        { x: 0.3, y: 0.38, role: 'Milieu offensif', index: 0 },
        { x: 0.7, y: 0.38, role: 'Milieu offensif', index: 1 },
        { x: 0.5, y: 0.52, role: 'Milieu d√©fensif' },
        // D√©fenseurs
        { x: 0.15, y: 0.7, role: 'Arri√®re lat√©ral gauche' },
        { x: 0.37, y: 0.75, role: 'D√©fenseur axial gauche' },
        { x: 0.63, y: 0.75, role: 'D√©fenseur axial droit' },
        { x: 0.85, y: 0.7, role: 'Arri√®re lat√©ral droit' }
      ],
      '4-4-2': [
        // Attaquants
        { x: 0.35, y: 0.15, role: 'Attaquant', index: 0 },
        { x: 0.65, y: 0.15, role: 'Attaquant', index: 1 },
        // Milieux
        { x: 0.15, y: 0.4, role: 'Ailier gauche' },
        { x: 0.4, y: 0.48, role: 'Milieu offensif' },
        { x: 0.6, y: 0.48, role: 'Milieu d√©fensif' },
        { x: 0.85, y: 0.4, role: 'Ailier droit' },
        // D√©fenseurs
        { x: 0.15, y: 0.7, role: 'Arri√®re lat√©ral gauche' },
        { x: 0.37, y: 0.75, role: 'D√©fenseur axial gauche' },
        { x: 0.63, y: 0.75, role: 'D√©fenseur axial droit' },
        { x: 0.85, y: 0.7, role: 'Arri√®re lat√©ral droit' }
      ],
      '3-4-3': [
        // Attaquants
        { x: 0.2, y: 0.15, role: 'Ailier gauche' },
        { x: 0.5, y: 0.1, role: 'Attaquant' },
        { x: 0.8, y: 0.15, role: 'Ailier droit' },
        // Milieux
        { x: 0.25, y: 0.4, role: 'Milieu offensif', index: 0 },
        { x: 0.75, y: 0.4, role: 'Milieu offensif', index: 1 },
        { x: 0.35, y: 0.55, role: 'Milieu d√©fensif', index: 0 },
        { x: 0.65, y: 0.55, role: 'Milieu d√©fensif', index: 1 },
        // D√©fenseurs
        { x: 0.25, y: 0.75, role: 'D√©fenseur axial gauche' },
        { x: 0.5, y: 0.78, role: 'D√©fenseur axial central' },
        { x: 0.75, y: 0.75, role: 'D√©fenseur axial droit' }
      ],
      '5-3-2': [
        // Attaquants
        { x: 0.35, y: 0.15, role: 'Attaquant', index: 0 },
        { x: 0.65, y: 0.15, role: 'Attaquant', index: 1 },
        // Milieux (2 offensifs + 1 d√©fensif)
        { x: 0.3, y: 0.43, role: 'Milieu offensif', index: 0 },
        { x: 0.7, y: 0.43, role: 'Milieu offensif', index: 1 },
        { x: 0.5, y: 0.56, role: 'Milieu d√©fensif' },
        // D√©fenseurs
        { x: 0.1, y: 0.68, role: 'Arri√®re lat√©ral gauche' },
        { x: 0.3, y: 0.75, role: 'D√©fenseur axial gauche' },
        { x: 0.5, y: 0.78, role: 'D√©fenseur axial central' },
        { x: 0.7, y: 0.75, role: 'D√©fenseur axial droit' },
        { x: 0.9, y: 0.68, role: 'Arri√®re lat√©ral droit' }
      ]
    };
    
    const positions = formations[selectedFormation];
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const setComicFont = (size, weight = 'bold') => {
      if (isMobile) {
        ctx.font = `${weight} ${size}px -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif`;
      } else {
        ctx.font = `${weight} ${size}px Comic Sans MS, Comic Sans, cursive, sans-serif`;
      }
    };
    
    // Dessiner les joueurs
    positions.forEach((pos, positionIndex) => {
      // Trouver le joueur correspondant √† ce poste
      let player;
      if (pos.index !== undefined) {
        // Pour les postes multiples (ex: 3 milieux offensifs), utiliser l'index
        const playersAtPosition = bestTeam.filter(p => p.position === pos.role);
        player = playersAtPosition[pos.index];
      } else {
        // Pour les postes uniques - g√©rer aussi les d√©fenseurs axiaux
        if (pos.role === 'D√©fenseur axial gauche' || pos.role === 'D√©fenseur axial droit' || pos.role === 'D√©fenseur axial central') {
          player = bestTeam.find(p => p.position === pos.role);
        } else {
          player = bestTeam.find(p => p.position === pos.role);
        }
      }
      
      if (!player) return;
      
      const x = 50 + (width - 100) * pos.x;
      const y = 50 + (height - 100) * pos.y;
      
      // Maillot (cercle de fond)
      const jerseyGradient = ctx.createRadialGradient(x, y - 5, 0, x, y - 5, 35);
      jerseyGradient.addColorStop(0, '#7E57C2');
      jerseyGradient.addColorStop(1, '#5e35b1');
      ctx.fillStyle = jerseyGradient;
      ctx.beginPath();
      ctx.arc(x, y, 35, 0, 2 * Math.PI);
      ctx.fill();
      
      // Bordure du maillot
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Nom du joueur - plus gros
      ctx.fillStyle = 'white';
      setComicFont(22, 'bold');
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      
      const name = player.Joueur.split(' ').pop().toUpperCase();
      ctx.fillText(name, x, y + 62);
      
      // √âquipe du joueur
      ctx.fillStyle = '#e0e0e0';
      setComicFont(16);
      ctx.fillText(player.√âquipe || '', x, y + 84);
      
      // Note du joueur - plus gros
      const note = (player.note || 0).toFixed(2);
      ctx.fillStyle = '#FFD700';
      setComicFont(26, 'bold');
      ctx.fillText(note, x, y + 110);
      
      // Minutes jou√©es
      const minutes = player['Minutes.jou√©es'] || 0;
      ctx.fillStyle = '#a0a0a0';
      setComicFont(15);
      ctx.fillText(`${minutes} min`, x, y + 130);
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    });
    
    // Titre de la formation
    ctx.fillStyle = 'white';
    setComicFont(36, 'bold');
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
    ctx.shadowBlur = 8;
    
    // Construire le titre avec les filtres actifs
    let title = '√âquipe type';
    const filters = [];
    
    if (selectedTeam) {
      filters.push(selectedTeam);
    }
    if (selectedChampionship) {
      filters.push(selectedChampionship);
    }
    if (selectedSeason) {
      filters.push(selectedSeason);
    }
    
    if (filters.length > 0) {
      title = `√âquipe type - ${filters.join(' ')}`;
    }
    
    ctx.fillText(title, width / 2, 55);
    
    // Formation et autres infos en sous-titre
    const subtitle = [];
    subtitle.push(`Formation ${selectedFormation}`);
    
    if (selectedPoste) {
      subtitle.push(selectedPoste);
    }
    if (minMinutes > 0) {
      subtitle.push(`‚â•${minMinutes} min`);
    }
    
    ctx.fillStyle = '#e0e0e0';
    setComicFont(22);
    ctx.fillText(subtitle.join(' ‚Ä¢ '), width / 2, 85);
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
  };

  const downloadExpandedChart = () => {
    if (!expandedChart) return;
    
    // Cr√©er un canvas temporaire pour le graphique
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = 1200;
    tempCanvas.height = 700;
    const ctx = tempCanvas.getContext('2d');
    
    // Fond
    ctx.fillStyle = '#1f2937';
    ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // Titre
    ctx.fillStyle = 'white';
    ctx.font = 'bold 24px Arial';
    ctx.textAlign = 'center';
    const title = expandedChart === 'note' && comparePlayer && evolutionStatsCompare.length > 0 
      ? `√âvolution de la Note : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
      : expandedChart === 'note' 
        ? `√âvolution de la Note de ${selectedPlayer.Joueur}`
        : expandedChart === 'buts' && comparePlayer && evolutionStatsCompare.length > 0
          ? `√âvolution des Buts : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
          : expandedChart === 'buts'
            ? `√âvolution des Buts de ${selectedPlayer.Joueur}`
            : comparePlayer && evolutionStatsCompare.length > 0
              ? `√âvolution des Passes d√©cisives : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
              : `√âvolution des Passes d√©cisives de ${selectedPlayer.Joueur}`;
    ctx.fillText(title, tempCanvas.width / 2, 40);
    
    // Convertir en blob et t√©l√©charger
    tempCanvas.toBlob((blob) => {
      if (!blob) {
        alert('Erreur lors de la cr√©ation de l\'image');
        return;
      }
      
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      const fileName = expandedChart === 'note' 
        ? 'evolution_note' 
        : expandedChart === 'buts' 
          ? 'evolution_buts' 
          : 'evolution_passes';
      link.download = `${fileName}_${selectedPlayer.Joueur.replace(/[^a-zA-Z0-9]/g, '_')}.png`;
      link.href = url;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      setTimeout(() => URL.revokeObjectURL(url), 100);
    }, 'image/png', 1.0);
  };

  const drawRadarComparison = () => {
    const canvas = radarComparisonRef.current;
    const ctx = canvas.getContext('2d');
    
    const isSmallScreen = window.innerWidth < 768;
    const scale = isSmallScreen ? 2 : 1;
    
    canvas.width = 800 * scale;
    canvas.height = 1400 * scale;
    canvas.style.width = '100%';
    canvas.style.height = 'auto';
    canvas.style.maxWidth = '800px';
    
    ctx.scale(scale, scale);
    
    const width = 800;
    const height = 1400;
    const centerX = width / 2;
    const centerY = height / 2 + 100;
    const maxRadius = Math.min(width, height) / 2.5;

    // Fond
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = '#010127';
    ctx.fillRect(0, 0, width, height);
    
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    const setComicFont = (size, weight = 'bold') => {
      if (isMobile) {
        ctx.font = `${weight} ${size}px -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif`;
      } else {
        ctx.font = `${weight} ${size}px Comic Sans MS, Comic Sans, cursive, sans-serif`;
      }
    };

    const numStats = stats.length;
    const angleStep = (2 * Math.PI) / numStats;

    // Cercles guides
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    [0.2, 0.4, 0.6, 0.8, 1].forEach(ratio => {
      ctx.beginPath();
      ctx.arc(centerX, centerY, maxRadius * ratio, 0, 2 * Math.PI);
      ctx.stroke();
    });
    ctx.setLineDash([]);

    // Lignes des axes
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(
        centerX + maxRadius * Math.cos(angle),
        centerY + maxRadius * Math.sin(angle)
      );
      ctx.stroke();
    });

    // Dessiner le radar du joueur principal (bleu)
    ctx.beginPath();
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      const value = selectedPlayer[stat.vingtile] || 0;
      const radius = (value / 20) * maxRadius;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.closePath();
    ctx.fillStyle = 'rgba(63, 81, 181, 0.3)';
    ctx.fill();
    ctx.strokeStyle = '#3F51B5';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Dessiner le radar du joueur compar√© (rose)
    ctx.beginPath();
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      const value = comparePlayer[stat.vingtile] || 0;
      const radius = (value / 20) * maxRadius;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    });
    ctx.closePath();
    ctx.fillStyle = 'rgba(244, 143, 177, 0.3)';
    ctx.fill();
    ctx.strokeStyle = '#F48FB1';
    ctx.lineWidth = 3;
    ctx.stroke();

    // Labels et valeurs
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    stats.forEach((stat, i) => {
      const angle = i * angleStep - Math.PI / 2;
      
      // Labels EXTERNES
      const labelRadius = maxRadius + 50;
      const labelX = centerX + labelRadius * Math.cos(angle);
      const labelY = centerY + labelRadius * Math.sin(angle);
      
      ctx.fillStyle = 'white';
      setComicFont(14);
      ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
      ctx.shadowBlur = 4;
      ctx.shadowOffsetX = 1;
      ctx.shadowOffsetY = 1;
      
      const lines = stat.label.split('\n');
      ctx.save();
      setComicFont(14);
      lines.forEach((line, j) => {
        ctx.fillText(line, labelX, labelY + (j - lines.length/2 + 0.5) * 16);
      });
      ctx.restore();
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // Points sur le radar avec valeurs
      const value1 = selectedPlayer[stat.vingtile] || 0;
      const radius1 = (value1 / 20) * maxRadius;
      const x1 = centerX + radius1 * Math.cos(angle);
      const y1 = centerY + radius1 * Math.sin(angle);
      
      ctx.beginPath();
      ctx.arc(x1, y1, 5, 0, 2 * Math.PI);
      ctx.fillStyle = '#3F51B5';
      ctx.fill();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Valeur pour joueur 1
      const displayValue1 = (selectedPlayer[stat.key] || 0).toFixed(2);
      ctx.save();
      setComicFont(14);
      const textWidth1 = ctx.measureText(displayValue1).width;
      const padding = 6;
      const boxHeight = 22;
      
      // D√©terminer la position de l'√©tiquette (vers l'ext√©rieur)
      const labelDistance = 25;
      const labelX1 = x1 + labelDistance * Math.cos(angle);
      const labelY1 = y1 + labelDistance * Math.sin(angle);
      
      // Ombre de la bo√Æte
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 6;
      ctx.fillStyle = '#3F51B5';
      ctx.fillRect(
        labelX1 - textWidth1/2 - padding, 
        labelY1 - boxHeight/2, 
        textWidth1 + padding * 2, 
        boxHeight
      );
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      // Bordure de la bo√Æte
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(
        labelX1 - textWidth1/2 - padding, 
        labelY1 - boxHeight/2, 
        textWidth1 + padding * 2, 
        boxHeight
      );
      
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.fillText(displayValue1, labelX1, labelY1);
      ctx.restore();

      const value2 = comparePlayer[stat.vingtile] || 0;
      const radius2 = (value2 / 20) * maxRadius;
      const x2 = centerX + radius2 * Math.cos(angle);
      const y2 = centerY + radius2 * Math.sin(angle);
      
      ctx.beginPath();
      ctx.arc(x2, y2, 5, 0, 2 * Math.PI);
      ctx.fillStyle = '#F48FB1';
      ctx.fill();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Valeur pour joueur 2
      const displayValue2 = (comparePlayer[stat.key] || 0).toFixed(2);
      ctx.save();
      setComicFont(14);
      const textWidth2 = ctx.measureText(displayValue2).width;
      
      // Positionner vers la gauche (vers le centre)
      const labelDistance2 = -15; // N√©gatif pour aller vers le centre
      const labelX2 = x2 + labelDistance2 * Math.cos(angle);
      const labelY2 = y2 + labelDistance2 * Math.sin(angle);
      
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowBlur = 6;
      ctx.fillStyle = '#F48FB1';
      ctx.fillRect(
        labelX2 - textWidth2/2 - padding, 
        labelY2 - boxHeight/2, 
        textWidth2 + padding * 2, 
        boxHeight
      );
      
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 1.5;
      ctx.strokeRect(
        labelX2 - textWidth2/2 - padding, 
        labelY2 - boxHeight/2, 
        textWidth2 + padding * 2, 
        boxHeight
      );
      
      ctx.fillStyle = '#1f2937';
      ctx.textAlign = 'center';
      ctx.fillText(displayValue2, labelX2, labelY2);
      ctx.restore();
    });

    // Informations des joueurs √† gauche et √† droite
    const infoBoxX = 30;
    const infoBoxY = 30;
    
    // JOUEUR 1 - √Ä GAUCHE
    // Nom du joueur 1
    ctx.save();
    ctx.textAlign = 'left';
    setComicFont(32);
    ctx.fillStyle = 'white';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 4;
    ctx.fillText(selectedPlayer.Joueur || 'Joueur 1', infoBoxX + 20, infoBoxY + 60);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();
    
    // Note globale joueur 1 sur la m√™me ligne, vers le milieu
    const noteX1 = width / 2 - 80;
    const noteY1 = infoBoxY + 50;
    const noteRadius = 40;
    
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    const noteGradient1 = ctx.createRadialGradient(noteX1 - 10, noteY1 - 10, 0, noteX1, noteY1, noteRadius);
    noteGradient1.addColorStop(0, '#5e8dd4');
    noteGradient1.addColorStop(1, '#3F51B5');
    ctx.fillStyle = noteGradient1;
    ctx.beginPath();
    ctx.arc(noteX1, noteY1, noteRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = 'white';
    setComicFont(32);
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 2;
    ctx.fillText((selectedPlayer.note || 0).toFixed(2), noteX1, noteY1 + 4);
    
    setComicFont(11);
    ctx.fillText('NOTE', noteX1, noteY1 + 22);
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();

    ctx.save();
    setComicFont(18);
    const infoLabels = [
      'Championnat:',
      '√âquipe:',
      'Saison:',
      'Poste:',
      'Profil:',
      '√Çge:',
      'Valeur:',
      'Contrat:',
      'Minutes:'
    ];
    
    const infoValues1 = [
      selectedPlayer.Championnat || 'N/A',
      selectedPlayer.√âquipe || 'N/A',
      selectedPlayer.Saison || 'N/A',
      getPosteFromProfil(selectedPlayer['Profil_detecte'], selectedPlayer.Place) || 'N/A',
      selectedPlayer['Profil_detecte'] || 'N/A',
      `${selectedPlayer.√Çge || 'N/A'} ans`,
      `${((selectedPlayer['Valeur.marchande'] || 0) / 1000000).toFixed(1)}M‚Ç¨`,
      selectedPlayer['Contrat.expiration'] || 'N/A',
      `${selectedPlayer['Minutes.jou√©es'] || 'N/A'} min`
    ];
    
    const labelX = infoBoxX + 20;
    const valueX = infoBoxX + 150;
    
    ctx.textAlign = 'left';
    ctx.fillStyle = 'white';
    infoLabels.forEach((label, i) => {
      setComicFont(18);
      ctx.fillText(label, labelX, infoBoxY + 115 + i * 28);
      
      setComicFont(16);
      ctx.fillText(infoValues1[i], valueX, infoBoxY + 115 + i * 28);
    });
    ctx.restore();
    
    // JOUEUR 2 - √Ä DROITE
    const infoBoxX2 = width - 360;
    
    // Nom du joueur 2
    ctx.save();
    ctx.textAlign = 'left';
    setComicFont(32);
    ctx.fillStyle = 'white';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
    ctx.shadowBlur = 4;
    ctx.fillText(comparePlayer.Joueur || 'Joueur 2', infoBoxX2 + 20, infoBoxY + 60);
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();
    
    // Note globale joueur 2 sur la m√™me ligne, √† droite
    const noteX2 = width - 90;
    const noteY2 = infoBoxY + 50;
    
    ctx.save();
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetX = 3;
    ctx.shadowOffsetY = 3;
    
    const noteGradient2 = ctx.createRadialGradient(noteX2 - 10, noteY2 - 10, 0, noteX2, noteY2, noteRadius);
    noteGradient2.addColorStop(0, '#f8a5c2');
    noteGradient2.addColorStop(1, '#F48FB1');
    ctx.fillStyle = noteGradient2;
    ctx.beginPath();
    ctx.arc(noteX2, noteY2, noteRadius, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    ctx.fillStyle = 'white';
    setComicFont(32);
    ctx.textAlign = 'center';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 2;
    ctx.fillText((comparePlayer.note || 0).toFixed(2), noteX2, noteY2 + 4);
    
    setComicFont(11);
    ctx.fillText('NOTE', noteX2, noteY2 + 22);
    
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.restore();
    
    ctx.save();
    setComicFont(18);
    
    const infoValues2 = [
      comparePlayer.Championnat || 'N/A',
      comparePlayer.√âquipe || 'N/A',
      comparePlayer.Saison || 'N/A',
      getPosteFromProfil(comparePlayer['Profil_detecte'], comparePlayer.Place) || 'N/A',
      comparePlayer['Profil_detecte'] || 'N/A',
      `${comparePlayer.√Çge || 'N/A'} ans`,
      `${((comparePlayer['Valeur.marchande'] || 0) / 1000000).toFixed(1)}M‚Ç¨`,
      comparePlayer['Contrat.expiration'] || 'N/A',
      `${comparePlayer['Minutes.jou√©es'] || 'N/A'} min`
    ];
    
    const labelX2 = infoBoxX2 + 20;
    const valueX2 = infoBoxX2 + 150;
    
    ctx.textAlign = 'left';
    ctx.fillStyle = 'white';
    infoLabels.forEach((label, i) => {
      setComicFont(18);
      ctx.fillText(label, labelX2, infoBoxY + 115 + i * 28);
      
      setComicFont(16);
      ctx.fillText(infoValues2[i], valueX2, infoBoxY + 115 + i * 28);
    });
    ctx.restore();
  };

  return (
    <div className="min-h-screen bg-[#010127] text-white p-4">
      <div className="max-w-7xl mx-auto">
        <div className="bg-gray-800/90 backdrop-blur rounded-xl shadow-2xl p-6 mb-6 border border-gray-700">
          <h1 className="text-2xl sm:text-3xl md:text-4xl font-bold mb-4 sm:mb-6 flex items-center gap-2 sm:gap-3" style={{ color: '#7E57C2' }}>
            JLB Data Football
          </h1>
          
          {/* Image Maradona */}
          <div className="flex justify-center mb-4">
            <img 
              src="https://i.imgur.com/8QZ3Z5L.png" 
              alt="Maradona" 
              className="w-48 h-auto rounded-lg shadow-lg"
              onError={(e) => {
                e.target.style.display = 'none';
              }}
            />
          </div>

          <div className="space-y-4 mb-4 sm:mb-6">
            <div>
              <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                <Upload size={16} />
                Importer un fichier CSV
              </label>
              <input
                type="file"
                accept=".csv"
                onChange={handleFileUpload}
                className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition"
              />
            </div>

            <div>
              <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                üåê Ou charger depuis une URL
              </label>
              <div className="flex flex-col sm:flex-row gap-2">
                <input
                  type="text"
                  placeholder="https://example.com/data.csv"
                  value={csvUrl}
                  onChange={(e) => setCsvUrl(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && loadCsvFromUrl(csvUrl)}
                  className="flex-1 px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition"
                  disabled={isLoading}
                />
                <button
                  onClick={() => loadCsvFromUrl(csvUrl)}
                  disabled={isLoading}
                  className="px-3 sm:px-4 md:px-6 py-1.5 sm:py-2 bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 rounded-lg transition shadow-lg disabled:opacity-50 disabled:cursor-not-allowed font-medium text-xs sm:text-sm whitespace-nowrap"
                >
                  {isLoading ? '‚è≥' : 'Charger'}
                </button>
              </div>
              <p className="text-xs text-gray-400 mt-1">
                Collez l'URL d'un fichier CSV h√©berg√©
              </p>
              {uploadStatus && (
                <p className="text-xs sm:text-sm mt-2 font-medium px-2 sm:px-3 py-1.5 sm:py-2 bg-gray-700/50 rounded">{uploadStatus}</p>
              )}
            </div>

            {players.length > 0 && (
              <>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3 sm:gap-4">
                  <div>
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üìÖ Saison
                    </label>
                    <select
                      value={selectedSeason}
                      onChange={(e) => setSelectedSeason(e.target.value)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition text-left"
                    >
                      {seasons.map((season, i) => (
                        <option key={i} value={season}>
                          {season}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üèÜ Championnat
                    </label>
                    <select
                      value={selectedChampionship}
                      onChange={(e) => setSelectedChampionship(e.target.value)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition text-left"
                    >
                      <option value="">Tous les championnats</option>
                      {championships.map((championship, i) => (
                        <option key={i} value={championship}>
                          {championship}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üèüÔ∏è √âquipe
                    </label>
                    <select
                      value={selectedTeam}
                      onChange={(e) => setSelectedTeam(e.target.value)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition text-left"
                    >
                      <option value="">Toutes les √©quipes</option>
                      {teams.map((team, i) => (
                        <option key={i} value={team}>
                          {team}
                        </option>
                      ))}
                    </select>
                  </div>

                  <div>
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üë§ Poste
                    </label>
                    <select
                      value={selectedPoste}
                      onChange={(e) => setSelectedPoste(e.target.value)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition text-left"
                    >
                      <option value="">Tous les postes</option>
                      {postesAgreges.map((poste, i) => (
                        <option key={i} value={poste}>
                          {poste}
                        </option>
                      ))}
                    </select>
                  </div>
                  
                  <div>
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üéØ Profil d√©tect√©
                    </label>
                    <select
                      value={selectedProfil}
                      onChange={(e) => setSelectedProfil(e.target.value)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500/50 transition text-left"
                    >
                      <option value="">Tous les profils</option>
                      {profilsDetectes.map((profil, i) => (
                        <option key={i} value={profil}>
                          {profil}
                        </option>
                      ))}
                    </select>
                  </div>
                </div>

                <div>
                  <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                    ‚è±Ô∏è Minutes jou√©es (minimum)
                  </label>
                  <div className="flex gap-2">
                    <button
                      onClick={() => setMinMinutes(0)}
                      className={`flex-1 px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-sm rounded-lg transition ${
                        minMinutes === 0 
                          ? 'bg-gradient-to-r from-purple-600 to-purple-700 text-white font-semibold' 
                          : 'bg-gray-700/70 hover:bg-gray-600/70'
                      }`}
                    >
                      Toutes
                    </button>
                    <button
                      onClick={() => setMinMinutes(500)}
                      className={`flex-1 px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-sm rounded-lg transition ${
                        minMinutes === 500 
                          ? 'bg-gradient-to-r from-purple-600 to-purple-700 text-white font-semibold' 
                          : 'bg-gray-700/70 hover:bg-gray-600/70'
                      }`}
                    >
                      ‚â• 500
                    </button>
                    <button
                      onClick={() => setMinMinutes(800)}
                      className={`flex-1 px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-sm rounded-lg transition ${
                        minMinutes === 800 
                          ? 'bg-gradient-to-r from-purple-600 to-purple-700 text-white font-semibold' 
                          : 'bg-gray-700/70 hover:bg-gray-600/70'
                      }`}
                    >
                      ‚â• 800
                    </button>
                    <button
                      onClick={() => setMinMinutes(1500)}
                      className={`flex-1 px-2 sm:px-4 py-1.5 sm:py-2 text-xs sm:text-sm rounded-lg transition ${
                        minMinutes === 1500 
                          ? 'bg-gradient-to-r from-purple-600 to-purple-700 text-white font-semibold' 
                          : 'bg-gray-700/70 hover:bg-gray-600/70'
                      }`}
                    >
                      ‚â• 1500
                    </button>
                  </div>
                </div>

                <div className="player-dropdown-container">
                  <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                    <Users size={16} />
                    Joueur ({filteredPlayers.length} disponible{filteredPlayers.length > 1 ? 's' : ''})
                  </label>
                  <div className="relative">
                    <input
                      type="text"
                      placeholder="Rechercher un joueur..."
                      value={playerSearchTerm}
                      onChange={(e) => {
                        setPlayerSearchTerm(e.target.value);
                        setShowPlayerDropdown(true);
                      }}
                      onFocus={() => setShowPlayerDropdown(true)}
                      className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition"
                      disabled={filteredPlayers.length === 0}
                    />
                    {selectedPlayer && (
                      <button
                        onClick={() => {
                          setSelectedPlayer(null);
                          setPlayerSearchTerm('');
                        }}
                        className="absolute right-2 top-1/2 -translate-y-1/2 text-red-400 hover:text-red-300 font-bold"
                      >
                        ‚úï
                      </button>
                    )}
                    
                    {showPlayerDropdown && (
                      <div className="absolute z-50 w-full mt-1 bg-gray-700 border border-gray-600 rounded-lg shadow-xl max-h-60 overflow-y-auto">
                        <div 
                          className="px-3 py-2 hover:bg-gray-600 cursor-pointer text-xs sm:text-sm"
                          onClick={() => {
                            setSelectedPlayer(null);
                            setPlayerSearchTerm('');
                            setShowPlayerDropdown(false);
                          }}
                        >
                          -- Aucun joueur s√©lectionn√© --
                        </div>
                        {filteredPlayers
                          .filter(p => 
                            playerSearchTerm === '' || 
                            p.Joueur.toLowerCase().includes(playerSearchTerm.toLowerCase())
                          )
                          .sort((a, b) => (a.Joueur || '').localeCompare(b.Joueur || ''))
                          .slice(0, 50)
                          .map((player, i) => (
                            <div
                              key={i}
                              className="px-3 py-2 hover:bg-gray-600 cursor-pointer text-xs sm:text-sm border-t border-gray-600/50"
                              onClick={() => {
                                setSelectedPlayer(player);
                                setPlayerSearchTerm(player.Joueur);
                                setShowPlayerDropdown(false);
                              }}
                            >
                              <div className="font-medium">{player.Joueur}</div>
                              <div className="text-xs text-gray-400">
                                {player.√âquipe} - {player.Saison}
                              </div>
                            </div>
                          ))
                        }
                        {filteredPlayers
                          .filter(p => 
                            playerSearchTerm === '' || 
                            p.Joueur.toLowerCase().includes(playerSearchTerm.toLowerCase())
                          ).length === 0 && (
                            <div className="px-3 py-2 text-xs sm:text-sm text-gray-400">
                              Aucun joueur trouv√©
                            </div>
                          )
                        }
                      </div>
                    )}
                  </div>
                </div>
                
                {showEvolution && (
                  <div className="compare-dropdown-container">
                    <label className="block text-xs sm:text-sm font-medium mb-2 flex items-center gap-2">
                      üîÑ Comparer avec un autre joueur
                    </label>
                    <div className="relative">
                      <input
                        type="text"
                        placeholder="Rechercher un joueur..."
                        value={compareSearchTerm}
                        onChange={(e) => {
                          setCompareSearchTerm(e.target.value);
                          setShowCompareDropdown(true);
                        }}
                        onFocus={() => setShowCompareDropdown(true)}
                        className="w-full px-2 sm:px-3 md:px-4 py-1.5 sm:py-2 text-xs sm:text-sm bg-gray-700/70 rounded-lg border border-gray-600 focus:border-purple-500 focus:outline-none focus:ring-2 focus:ring-purple-500/50 transition"
                      />
                      {comparePlayer && (
                        <button
                          onClick={() => {
                            setComparePlayer(null);
                            setCompareSearchTerm('');
                          }}
                          className="absolute right-2 top-1/2 -translate-y-1/2 text-red-400 hover:text-red-300 font-bold"
                        >
                          ‚úï
                        </button>
                      )}
                      
                      {showCompareDropdown && (
                        <div className="absolute z-50 w-full mt-1 bg-gray-700 border border-gray-600 rounded-lg shadow-xl max-h-60 overflow-y-auto">
                          <div 
                            className="px-3 py-2 hover:bg-gray-600 cursor-pointer text-xs sm:text-sm"
                            onClick={() => {
                              setComparePlayer(null);
                              setCompareSearchTerm('');
                              setShowCompareDropdown(false);
                            }}
                          >
                            -- Aucune comparaison --
                          </div>
                          {filteredPlayers
                            .filter(p => p.Joueur !== selectedPlayer?.Joueur)
                            .filter((p, index, self) => 
                              index === self.findIndex((t) => t.Joueur === p.Joueur)
                            )
                            .filter(p => 
                              compareSearchTerm === '' || 
                              p.Joueur.toLowerCase().includes(compareSearchTerm.toLowerCase())
                            )
                            .sort((a, b) => (a.Joueur || '').localeCompare(b.Joueur || ''))
                            .slice(0, 50)
                            .map((player, i) => (
                              <div
                                key={i}
                                className="px-3 py-2 hover:bg-gray-600 cursor-pointer text-xs sm:text-sm border-t border-gray-600/50"
                                onClick={() => {
                                  setComparePlayer(player);
                                  setCompareSearchTerm(player.Joueur);
                                  setShowCompareDropdown(false);
                                }}
                              >
                                <div className="font-medium">{player.Joueur}</div>
                                <div className="text-xs text-gray-400">
                                  {player.√âquipe} - {player.Saison}
                                </div>
                              </div>
                            ))
                          }
                          {filteredPlayers
                            .filter(p => p.Joueur !== selectedPlayer?.Joueur)
                            .filter((p, index, self) => 
                              index === self.findIndex((t) => t.Joueur === p.Joueur)
                            )
                            .filter(p => 
                              compareSearchTerm === '' || 
                              p.Joueur.toLowerCase().includes(compareSearchTerm.toLowerCase())
                            ).length === 0 && (
                              <div className="px-3 py-2 text-xs sm:text-sm text-gray-400">
                                Aucun joueur trouv√©
                              </div>
                            )
                          }
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </>
            )}
          </div>

          <div className="flex flex-wrap gap-2 sm:gap-4 mb-2">
            <button
              onClick={() => setShowTopPlayers(!showTopPlayers)}
              disabled={filteredPlayers.length === 0}
              className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <Users size={14} className="sm:w-4 sm:h-4" />
              <span className="hidden sm:inline">{showTopPlayers ? 'Masquer' : 'Meilleurs joueurs'}</span>
              <span className="sm:hidden">{showTopPlayers ? 'Masquer' : 'Top'}</span>
            </button>
            
            <button
              onClick={() => setShowBestTeam(!showBestTeam)}
              disabled={filteredPlayers.length === 0}
              className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <Users size={14} className="sm:w-4 sm:h-4" />
              <span className="hidden sm:inline">{showBestTeam ? 'Masquer √©quipe type' : '√âquipe type'}</span>
              <span className="sm:hidden">{showBestTeam ? 'Masquer' : '√âquipe'}</span>
            </button>
            
            {selectedPlayer && (
              <button
                onClick={() => setShowEvolution(!showEvolution)}
                className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105"
              >
                <TrendingUp size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">{showEvolution ? 'Masquer √©volution' : 'Voir √©volution'}</span>
                <span className="sm:hidden">{showEvolution ? 'Masquer' : '√âvolution'}</span>
              </button>
            )}
            
            {selectedPlayer && (
              <button
                onClick={() => setShowSimilarPlayers(!showSimilarPlayers)}
                className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-teal-600 to-teal-700 hover:from-teal-700 hover:to-teal-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105"
              >
                <Users size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">{showSimilarPlayers ? 'Masquer similaires' : 'Joueurs similaires'}</span>
                <span className="sm:hidden">{showSimilarPlayers ? 'Masquer' : 'Similaires'}</span>
              </button>
            )}
            
            <button
              onClick={() => setShowSeasonFilter(!showSeasonFilter)}
              disabled={filteredPlayers.length === 0}
              className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-indigo-600 to-indigo-700 hover:from-indigo-700 hover:to-indigo-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none"
            >
              <TrendingUp size={14} className="sm:w-4 sm:h-4" />
              <span className="hidden sm:inline">{showSeasonFilter ? 'Masquer filtre notes' : 'Filtrer par notes/saison'}</span>
              <span className="sm:hidden">{showSeasonFilter ? 'Masquer' : 'Notes'}</span>
            </button>
            
            {selectedPlayer && (
              <button
                onClick={() => {
                  if (!showEvolution) {
                    setShowEvolution(true);
                  }
                }}
                className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-orange-600 to-orange-700 hover:from-orange-700 hover:to-orange-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105"
              >
                <Users size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">Comparer avec un autre joueur</span>
                <span className="sm:hidden">Comparer</span>
              </button>
            )}
            
            {comparePlayer && (
              <button
                onClick={() => setShowRadarComparison(!showRadarComparison)}
                className="flex items-center gap-2 px-3 sm:px-6 py-2 sm:py-2.5 text-xs sm:text-sm bg-gradient-to-r from-pink-600 to-pink-700 hover:from-pink-700 hover:to-pink-800 rounded-lg transition shadow-lg hover:shadow-xl transform hover:scale-105"
              >
                <Users size={14} className="sm:w-4 sm:h-4" />
                <span className="hidden sm:inline">{showRadarComparison ? 'Masquer radar' : 'Radar comparaison'}</span>
                <span className="sm:hidden">{showRadarComparison ? 'Masquer' : 'Radar'}</span>
              </button>
            )}
          </div>
          {showSimilarPlayers && selectedPlayer && (
            <div className="mt-4 bg-gray-700/50 rounded-lg p-4">
              <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-lg">Joueurs similaires √† {selectedPlayer.Joueur}</h3>
                <div className="text-sm text-gray-400">
                  M√™me poste : {getPosteFromProfil(selectedPlayer['Profil_detecte'], selectedPlayer.Place, selectedPlayer.Joueur)}
                </div>
              </div>
              
              {similarPlayers.length === 0 ? (
                <div className="text-center py-8 text-gray-400">
                  Aucun joueur similaire trouv√© pour ce poste
                </div>
              ) : (
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="border-b border-gray-600">
                        <th className="text-left py-2 px-2">#</th>
                        <th className="text-left py-2 px-2">Similarit√©</th>
                        <th className="text-left py-2 px-2">Joueur</th>
                        <th className="text-left py-2 px-2">√âquipe</th>
                        <th className="text-left py-2 px-2">Saison</th>
                        <th className="text-right py-2 px-2">Note</th>
                        <th className="text-right py-2 px-2">Minutes</th>
                        <th className="text-right py-2 px-2">Buts</th>
                        <th className="text-right py-2 px-2">Passes D.</th>
                      </tr>
                    </thead>
                    <tbody>
                      {similarPlayers.map((player, index) => {
                        // Calculer le pourcentage de similarit√© (inverser le score)
                        const similarityPercent = Math.max(0, Math.min(100, 100 - (player.similarityScore * 50)));
                        
                        return (
                          <tr 
                            key={index} 
                            className="border-b border-gray-600/50 hover:bg-gray-600/30 transition cursor-pointer"
                            onClick={() => setSelectedPlayer(player)}
                          >
                            <td className="py-2 px-2 font-bold text-teal-400">{index + 1}</td>
                            <td className="py-2 px-2">
                              <div className="flex items-center gap-2">
                                <div className="w-16 bg-gray-600 rounded-full h-2">
                                  <div 
                                    className="bg-teal-500 h-2 rounded-full" 
                                    style={{ width: `${similarityPercent}%` }}
                                  />
                                </div>
                                <span className="text-xs text-teal-400 font-semibold">
                                  {similarityPercent.toFixed(0)}%
                                </span>
                              </div>
                            </td>
                            <td className="py-2 px-2 font-medium hover:text-teal-400 hover:underline">
                              {player.Joueur}
                            </td>
                            <td className="py-2 px-2 text-gray-300">{player.√âquipe}</td>
                            <td className="py-2 px-2 text-gray-400 text-xs">{player.Saison}</td>
                            <td className="py-2 px-2 text-right font-bold text-yellow-400">
                              {(player.note || 0).toFixed(2)}
                            </td>
                            <td className="py-2 px-2 text-right text-gray-300">{player['Minutes.jou√©es'] || 0}</td>
                            <td className="py-2 px-2 text-right text-green-400">
                              {(player['Buts.par.90.min'] || 0).toFixed(2)}
                            </td>
                            <td className="py-2 px-2 text-right text-blue-400">
                              {(player['Passes.d√©cisives.par.90.min'] || 0).toFixed(2)}
                            </td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              )}
              
              <div className="mt-4 p-3 bg-teal-900/30 border border-teal-600/50 rounded-lg text-teal-200 text-sm">
                üí° La similarit√© se base principalement sur les <strong>statistiques d√©taill√©es</strong>. Note globale (tol√©rance ¬±1.2) et minutes jou√©es ont un impact mineur.
                <br/>
                ‚öñÔ∏è Poids prioritaires : Duels a√©riens/Interceptions (√ó4), Buts de t√™te/xG/Buts/xA (√ó3) - diff√©rencie les profils d√©fensifs, physiques et techniques.
                <br/>
                üëÜ Cliquez sur un joueur pour voir son radar.
              </div>
            </div>
          )}
          
          {showSeasonFilter && filteredPlayers.length > 0 && (
            <div className="mt-4 bg-gray-700/50 rounded-lg p-4">
              <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-lg">Filtrer par notes et saisons</h3>
              </div>
              
              <div className="space-y-4">
                {/* Slider de notes */}
                <div>
                  <label className="block text-sm font-medium mb-2">
                    Note entre {seasonFilters.minNote.toFixed(1)} et {seasonFilters.maxNote.toFixed(1)}
                  </label>
                  <div className="flex gap-4 items-center">
                    <input
                      type="range"
                      min="5.0"
                      max="10.0"
                      step="0.1"
                      value={seasonFilters.minNote}
                      onChange={(e) => setSeasonFilters({
                        ...seasonFilters,
                        minNote: parseFloat(e.target.value)
                      })}
                      className="flex-1"
                    />
                    <input
                      type="range"
                      min="5.0"
                      max="10.0"
                      step="0.1"
                      value={seasonFilters.maxNote}
                      onChange={(e) => setSeasonFilters({
                        ...seasonFilters,
                        maxNote: parseFloat(e.target.value)
                      })}
                      className="flex-1"
                    />
                  </div>
                </div>
                
                {/* S√©lection des saisons */}
                <div>
                  <label className="block text-sm font-medium mb-2">Saisons √† inclure</label>
                  <div className="flex flex-wrap gap-2">
                    {seasons.map((season) => {
                      const isSelected = seasonFilters.selectedSeasons.includes(season);
                      return (
                        <button
                          key={season}
                          onClick={() => {
                            if (isSelected) {
                              setSeasonFilters({
                                ...seasonFilters,
                                selectedSeasons: seasonFilters.selectedSeasons.filter(s => s !== season)
                              });
                            } else {
                              setSeasonFilters({
                                ...seasonFilters,
                                selectedSeasons: [...seasonFilters.selectedSeasons, season]
                              });
                            }
                          }}
                          className={`px-3 py-1.5 text-sm rounded-lg transition ${
                            isSelected 
                              ? 'bg-indigo-600 text-white font-semibold' 
                              : 'bg-gray-600 hover:bg-gray-500'
                          }`}
                        >
                          {season}
                        </button>
                      );
                    })}
                  </div>
                  <button
                    onClick={() => setSeasonFilters({
                      ...seasonFilters,
                      selectedSeasons: seasons
                    })}
                    className="mt-2 text-xs text-indigo-400 hover:text-indigo-300"
                  >
                    Toutes les saisons
                  </button>
                </div>
                
                {/* Filtre par poste */}
                <div>
                  <label className="block text-sm font-medium mb-2">üë§ Filtrer par poste</label>
                  <select
                    value={seasonFilters.selectedPoste || ''}
                    onChange={(e) => setSeasonFilters({
                      ...seasonFilters,
                      selectedPoste: e.target.value
                    })}
                    className="w-full px-3 py-2 text-sm bg-gray-600 rounded-lg border border-gray-500 focus:border-indigo-500 focus:outline-none"
                  >
                    <option value="">Tous les postes</option>
                    {postesAgreges.map((poste, i) => (
                      <option key={i} value={poste}>
                        {poste}
                      </option>
                    ))}
                  </select>
                </div>
                
                {/* Filtre minutes jou√©es */}
                <div>
                  <label className="block text-sm font-medium mb-2">
                    ‚è±Ô∏è Minutes jou√©es minimum (total sur toutes les saisons)
                  </label>
                  <div className="flex gap-2">
                    <button
                      onClick={() => setSeasonFilters({
                        ...seasonFilters,
                        minMinutes: 0
                      })}
                      className={`flex-1 px-3 py-1.5 text-sm rounded-lg transition ${
                        (seasonFilters.minMinutes || 0) === 0
                          ? 'bg-indigo-600 text-white font-semibold' 
                          : 'bg-gray-600 hover:bg-gray-500'
                      }`}
                    >
                      Toutes
                    </button>
                    <button
                      onClick={() => setSeasonFilters({
                        ...seasonFilters,
                        minMinutes: 500
                      })}
                      className={`flex-1 px-3 py-1.5 text-sm rounded-lg transition ${
                        seasonFilters.minMinutes === 500
                          ? 'bg-indigo-600 text-white font-semibold' 
                          : 'bg-gray-600 hover:bg-gray-500'
                      }`}
                    >
                      ‚â• 500
                    </button>
                    <button
                      onClick={() => setSeasonFilters({
                        ...seasonFilters,
                        minMinutes: 1000
                      })}
                      className={`flex-1 px-3 py-1.5 text-sm rounded-lg transition ${
                        seasonFilters.minMinutes === 1000
                          ? 'bg-indigo-600 text-white font-semibold' 
                          : 'bg-gray-600 hover:bg-gray-500'
                      }`}
                    >
                      ‚â• 1000
                    </button>
                    <button
                      onClick={() => setSeasonFilters({
                        ...seasonFilters,
                        minMinutes: 2000
                      })}
                      className={`flex-1 px-3 py-1.5 text-sm rounded-lg transition ${
                        seasonFilters.minMinutes === 2000
                          ? 'bg-indigo-600 text-white font-semibold' 
                          : 'bg-gray-600 hover:bg-gray-500'
                      }`}
                    >
                      ‚â• 2000
                    </button>
                    <button
                      onClick={() => setSeasonFilters({
                        ...seasonFilters,
                        minMinutes: 3000
                      })}
                      className={`flex-1 px-3 py-1.5 text-sm rounded-lg transition ${
                        seasonFilters.minMinutes === 3000
                          ? 'bg-indigo-600 text-white font-semibold' 
                          : 'bg-gray-600 hover:bg-gray-500'
                      }`}
                    >
                      ‚â• 3000
                    </button>
                  </div>
                </div>
                
                {/* Filtre valeur marchande */}
                <div>
                  <label className="block text-sm font-medium mb-2">
                    üí∞ Valeur marchande entre {seasonFilters.minValeurMarchande}M‚Ç¨ et {seasonFilters.maxValeurMarchande === 200 ? '200M‚Ç¨+' : seasonFilters.maxValeurMarchande + 'M‚Ç¨'}
                  </label>
                  <div className="space-y-2">
                    <div className="flex gap-4 items-center">
                      <span className="text-xs text-gray-400 w-16">Min:</span>
                      <input
                        type="range"
                        min="0"
                        max="200"
                        step="5"
                        value={seasonFilters.minValeurMarchande}
                        onChange={(e) => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: parseInt(e.target.value)
                        })}
                        className="flex-1"
                      />
                    </div>
                    <div className="flex gap-4 items-center">
                      <span className="text-xs text-gray-400 w-16">Max:</span>
                      <input
                        type="range"
                        min="0"
                        max="200"
                        step="5"
                        value={seasonFilters.maxValeurMarchande}
                        onChange={(e) => setSeasonFilters({
                          ...seasonFilters,
                          maxValeurMarchande: parseInt(e.target.value)
                        })}
                        className="flex-1"
                      />
                    </div>
                    <div className="flex gap-2 flex-wrap">
                      <button
                        onClick={() => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: 0,
                          maxValeurMarchande: 200
                        })}
                        className="px-3 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
                      >
                        Toutes valeurs
                      </button>
                      <button
                        onClick={() => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: 0,
                          maxValeurMarchande: 5
                        })}
                        className="px-3 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
                      >
                        &lt; 5M‚Ç¨
                      </button>
                      <button
                        onClick={() => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: 5,
                          maxValeurMarchande: 20
                        })}
                        className="px-3 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
                      >
                        5-20M‚Ç¨
                      </button>
                      <button
                        onClick={() => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: 20,
                          maxValeurMarchande: 50
                        })}
                        className="px-3 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
                      >
                        20-50M‚Ç¨
                      </button>
                      <button
                        onClick={() => setSeasonFilters({
                          ...seasonFilters,
                          minValeurMarchande: 50,
                          maxValeurMarchande: 200
                        })}
                        className="px-3 py-1 text-xs bg-gray-600 hover:bg-gray-500 rounded transition"
                      >
                        &gt; 50M‚Ç¨
                      </button>
                    </div>
                  </div>
                </div>
                
                {/* R√©sultats avec note moyenne */}
                <div className="mt-4">
                  <h4 className="font-semibold mb-2">
                    R√©sultats ({
                      (() => {
                        // Grouper par joueur et calculer note moyenne
                        const playerGroups = {};
                        players.forEach(p => {
                          const noteValid = p.note >= seasonFilters.minNote && p.note <= seasonFilters.maxNote;
                          const seasonValid = seasonFilters.selectedSeasons.length === 0 || 
                                            seasonFilters.selectedSeasons.includes(p.Saison);
                          
                          if (noteValid && seasonValid) {
                            if (!playerGroups[p.Joueur]) {
                              playerGroups[p.Joueur] = [];
                            }
                            playerGroups[p.Joueur].push(p);
                          }
                        });
                        
                        // Ne compter que les joueurs avec plusieurs saisons
                        return Object.keys(playerGroups).length;
                      })()
                    } joueurs)
                  </h4>
                  
                  <div className="overflow-x-auto max-h-96 overflow-y-auto">
                    <table className="w-full text-sm">
                      <thead className="sticky top-0 bg-gray-700">
                        <tr className="border-b border-gray-600">
                          <th className="text-left py-2 px-2">Joueur</th>
                          <th className="text-left py-2 px-2">Saisons</th>
                          <th className="text-right py-2 px-2">Valeur</th>
                          <th className="text-right py-2 px-2">Note Moy.</th>
                          <th className="text-right py-2 px-2">Note Min</th>
                          <th className="text-right py-2 px-2">Note Max</th>
                          <th className="text-right py-2 px-2">Total Min.</th>
                          <th className="text-right py-2 px-2">Buts Moy.</th>
                          <th className="text-right py-2 px-2">PD Moy.</th>
                        </tr>
                      </thead>
                      <tbody>
                        {(() => {
                          // Grouper par joueur
                          const playerGroups = {};
                          
                          players.forEach(p => {
                            const noteValid = p.note >= seasonFilters.minNote && p.note <= seasonFilters.maxNote;
                            const seasonValid = seasonFilters.selectedSeasons.length === 0 || 
                                              seasonFilters.selectedSeasons.includes(p.Saison);
                            
                            // Filtre valeur marchande (en millions)
                            const valeurMarchandeM = (p['Valeur.marchande'] || 0) / 1000000;
                            const valeurValid = valeurMarchandeM >= seasonFilters.minValeurMarchande && 
                                              valeurMarchandeM <= seasonFilters.maxValeurMarchande;
                            
                            if (noteValid && seasonValid && valeurValid) {
                              // Cr√©er une cl√© unique par joueur + saison pour √©viter les doublons
                              if (!playerGroups[p.Joueur]) {
                                playerGroups[p.Joueur] = {
                                  seasons: {},
                                  name: p.Joueur
                                };
                              }
                              
                              // Une seule entr√©e par saison (la premi√®re trouv√©e)
                              if (!playerGroups[p.Joueur].seasons[p.Saison]) {
                                playerGroups[p.Joueur].seasons[p.Saison] = p;
                              }
                            }
                          });
                          
                          // Appliquer les filtres APR√àS avoir regroup√©
                          Object.keys(playerGroups).forEach(name => {
                            // Filtre de poste : v√©rifier si au moins UNE saison correspond
                            if (seasonFilters.selectedPoste) {
                              const hasPoste = Object.values(playerGroups[name].seasons).some(s => 
                                getPosteFromProfil(s['Profil_detecte'], s.Place, s.Joueur) === seasonFilters.selectedPoste
                              );
                              
                              if (!hasPoste) {
                                delete playerGroups[name];
                                return;
                              }
                            }
                            
                            // Filtre de minutes : calculer le TOTAL des minutes sur toutes les saisons
                            if (seasonFilters.minMinutes && seasonFilters.minMinutes > 0) {
                              const totalMinutes = Object.values(playerGroups[name].seasons)
                                .reduce((sum, s) => sum + (s['Minutes.jou√©es'] || 0), 0);
                              
                              if (totalMinutes < seasonFilters.minMinutes) {
                                delete playerGroups[name];
                                return;
                              }
                            }
                            
                            // Nettoyer les joueurs sans saisons valides
                            if (playerGroups[name] && Object.keys(playerGroups[name].seasons).length === 0) {
                              delete playerGroups[name];
                            }
                          });
                          
                          // Calculer les statistiques moyennes
                          return Object.entries(playerGroups)
                            .map(([name, groupData]) => {
                              const seasons = Object.values(groupData.seasons);
                              const totalMinutes = seasons.reduce((sum, s) => sum + (s['Minutes.jou√©es'] || 0), 0);
                              
                              // Note moyenne pond√©r√©e par les minutes
                              const noteWeighted = seasons.reduce((sum, s) => 
                                sum + (s.note || 0) * (s['Minutes.jou√©es'] || 0), 0) / totalMinutes;
                              
                              const noteMin = Math.min(...seasons.map(s => s.note || 0));
                              const noteMax = Math.max(...seasons.map(s => s.note || 0));
                              
                              // Buts et passes moyens pond√©r√©s
                              const butsWeighted = seasons.reduce((sum, s) => 
                                sum + (s['Buts.par.90.min'] || 0) * (s['Minutes.jou√©es'] || 0), 0) / totalMinutes;
                              
                              const passesWeighted = seasons.reduce((sum, s) => 
                                sum + (s['Passes.d√©cisives.par.90.min'] || 0) * (s['Minutes.jou√©es'] || 0), 0) / totalMinutes;
                              
                              // Valeur marchande la plus r√©cente
                              const latestSeason = seasons.reduce((latest, s) => 
                                s.Saison > latest.Saison ? s : latest, seasons[0]);
                              const valeurMarchande = latestSeason['Valeur.marchande'] || 0;
                              
                              return {
                                name,
                                seasons: seasons.map(s => s.Saison).sort().join(', '),
                                seasonCount: seasons.length,
                                noteAvg: noteWeighted,
                                noteMin,
                                noteMax,
                                totalMinutes,
                                butsAvg: butsWeighted,
                                passesAvg: passesWeighted,
                                valeurMarchande,
                                latestSeason
                              };
                            })
                            .sort((a, b) => {
                              // Tri par note moyenne d√©croissante
                              return b.noteAvg - a.noteAvg;
                            })
                            .slice(0, 100)
                            .map((player, index) => (
                              <tr 
                                key={index}
                                className="border-b border-gray-600/50 hover:bg-gray-600/30 transition cursor-pointer"
                                onClick={() => setSelectedPlayer(player.latestSeason)}
                              >
                                <td className="py-2 px-2 font-medium hover:text-indigo-400">
                                  {player.name}
                                  {player.seasonCount > 1 && (
                                    <span className="ml-2 text-xs text-indigo-400">
                                      ({player.seasonCount} saisons)
                                    </span>
                                  )}
                                  <div className="text-xs text-gray-500 mt-1">
                                    {getPosteFromProfil(player.latestSeason['Profil_detecte'], player.latestSeason.Place, player.latestSeason.Joueur) || 'N/A'}
                                  </div>
                                </td>
                                <td className="py-2 px-2 text-gray-400 text-xs max-w-[150px] truncate" title={player.seasons}>
                                  {player.seasons}
                                </td>
                                <td className="py-2 px-2 text-right font-bold text-green-400">
                                  {(player.valeurMarchande / 1000000).toFixed(1)}M‚Ç¨
                                </td>
                                <td className="py-2 px-2 text-right font-bold text-yellow-400">
                                  {player.noteAvg.toFixed(2)}
                                </td>
                                <td className="py-2 px-2 text-right text-orange-400">
                                  {player.noteMin.toFixed(2)}
                                </td>
                                <td className="py-2 px-2 text-right text-green-400">
                                  {player.noteMax.toFixed(2)}
                                </td>
                                <td className="py-2 px-2 text-right text-gray-300">
                                  {player.totalMinutes}
                                </td>
                                <td className="py-2 px-2 text-right text-green-400">
                                  {player.butsAvg.toFixed(2)}
                                </td>
                                <td className="py-2 px-2 text-right text-blue-400">
                                  {player.passesAvg.toFixed(2)}
                                </td>
                              </tr>
                            ));
                        })()}
                      </tbody>
                    </table>
                  </div>
                  
                  <div className="mt-4 p-3 bg-indigo-900/30 border border-indigo-600/50 rounded-lg text-indigo-200 text-sm">
                    üí° <strong>Note Moy.</strong> = Note moyenne pond√©r√©e par les minutes jou√©es sur les saisons s√©lectionn√©es
                    <br/>
                    üí∞ <strong>Valeur</strong> = Valeur marchande la plus r√©cente du joueur
                    <br/>
                    üìä Les joueurs sont tri√©s par note moyenne d√©croissante
                    <br/>
                    ‚öΩ <strong>Important</strong> : Chaque saison ne compte qu'une seule fois par joueur, ind√©pendamment des postes jou√©s
                    <br/>
                    üéØ Le filtre de poste permet de ne voir que les joueurs ayant jou√© √† ce poste (au moins une saison), mais la moyenne inclut TOUTES leurs saisons valides
                    <br/>
                    ‚è±Ô∏è Le filtre de minutes s'applique au <strong>TOTAL</strong> des minutes sur toutes les saisons (pas par saison)
                    <br/>
                    üëÜ Cliquez sur un joueur pour voir son radar (derni√®re saison)
                  </div>
                </div>
              </div>
            </div>
          )}
          
          {showBestTeam && filteredPlayers.length > 0 && (
            <div className="mt-4 bg-gray-700/50 rounded-lg p-4">
              <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-lg">√âquipe type</h3>
                <div className="flex gap-2">
                  <select
                    value={selectedFormation}
                    onChange={(e) => setSelectedFormation(e.target.value)}
                    className="px-3 py-1.5 text-sm bg-gray-600 rounded-lg border border-gray-500 focus:border-green-500 focus:outline-none"
                  >
                    <option value="4-3-3">4-3-3</option>
                    <option value="4-4-2">4-4-2</option>
                    <option value="3-4-3">3-4-3</option>
                    <option value="5-3-2">5-3-2</option>
                  </select>
                  <button
                    onClick={() => setShowFieldView(!showFieldView)}
                    className="px-3 py-1.5 text-sm bg-green-600 hover:bg-green-700 rounded-lg transition"
                  >
                    {showFieldView ? 'üìã Vue tableau' : '‚öΩ Vue terrain'}
                  </button>
                </div>
              </div>
              
              {showFieldView ? (
                <div className="flex flex-col items-center">
                  <canvas
                    ref={fieldCanvasRef}
                    width={800}
                    height={600}
                    className="w-full h-auto rounded-lg shadow-2xl"
                  />
                  <button
                    onClick={() => {
                      const canvas = fieldCanvasRef.current;
                      canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.download = `equipe_type_${selectedFormation}.png`;
                        link.href = url;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        setTimeout(() => URL.revokeObjectURL(url), 100);
                      }, 'image/png', 1.0);
                    }}
                    className="mt-4 flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg transition"
                  >
                    <Download size={16} />
                    T√©l√©charger l'√©quipe type
                  </button>
                </div>
              ) : (
                <div className="overflow-x-auto">
                  <table className="w-full text-sm">
                    <thead>
                      <tr className="border-b border-gray-600">
                        <th className="text-left py-2 px-2">Poste</th>
                        <th className="text-left py-2 px-2">Joueur</th>
                        <th className="text-left py-2 px-2">√âquipe</th>
                        <th className="text-right py-2 px-2">Note</th>
                        <th className="text-right py-2 px-2">Minutes</th>
                        <th className="text-right py-2 px-2">Buts</th>
                        <th className="text-right py-2 px-2">Passes D.</th>
                      </tr>
                    </thead>
                    <tbody>
                      {bestTeam
                        .sort((a, b) => {
                          const order = {
                            'Attaquant': 1,
                            'Ailier gauche': 2,
                            'Ailier droit': 3,
                            'Milieu offensif': 4,
                            'Milieu d√©fensif': 5,
                            'Arri√®re lat√©ral gauche': 6,
                            'Arri√®re lat√©ral droit': 7,
                            'D√©fenseur axial gauche': 8,
                            'D√©fenseur axial central': 8.5,
                            'D√©fenseur axial droit': 9
                          };
                          return order[a.position] - order[b.position];
                        })
                        .map((player, index) => (
                          <tr 
                            key={index} 
                            className="border-b border-gray-600/50 hover:bg-gray-600/30 transition"
                          >
                            <td className="py-2 px-2 font-medium text-green-400">{player.position}</td>
                            <td className="py-2 px-2">
                              <button
                                onClick={() => setSelectedPlayer(player)}
                                className="font-medium text-left hover:text-purple-400 hover:underline transition"
                              >
                                {player.Joueur}
                              </button>
                              {player.isReplacement && (
                                <span className="ml-2 text-xs text-yellow-400">
                                  (depuis {player.originalPosition})
                                </span>
                              )}
                            </td>
                            <td className="py-2 px-2 text-gray-300">{player.√âquipe}</td>
                            <td className="py-2 px-2 text-right font-bold text-yellow-400">{(player.note || 0).toFixed(2)}</td>
                            <td className="py-2 px-2 text-right text-gray-300">{player['Minutes.jou√©es'] || 0}</td>
                            <td className="py-2 px-2 text-right text-green-400">
                              {(player['Buts.par.90.min'] || 0).toFixed(2)}
                            </td>
                            <td className="py-2 px-2 text-right text-blue-400">
                              {(player['Passes.d√©cisives.par.90.min'] || 0).toFixed(2)}
                            </td>
                            <td className="py-2 px-2 text-xs text-gray-400">
                              {getPosteFromProfil(player['Profil_detecte'], player.Place) || 'N/A'}
                            </td>
                          </tr>
                        ))}
                    </tbody>
                  </table>
                </div>
              )}
              
              {bestTeam.length < 11 && (
                <div className="mt-4 p-3 bg-yellow-900/30 border border-yellow-600/50 rounded-lg text-yellow-200 text-sm">
                  ‚ö†Ô∏è Attention : Seulement {bestTeam.length} joueur(s) trouv√©(s) pour cette formation. Certains postes n'ont pas de joueurs disponibles dans les donn√©es filtr√©es.
                </div>
              )}
            </div>
          )}
          
          {showTopPlayers && filteredPlayers.length > 0 && (
            <div className="mt-4 bg-gray-700/50 rounded-lg p-4">
              <div className="flex items-center justify-between mb-4">
                <h3 className="font-bold text-lg">Top joueurs par note</h3>
                <select
                  value={topPlayersCount}
                  onChange={(e) => setTopPlayersCount(Number(e.target.value))}
                  className="px-3 py-1.5 text-sm bg-gray-600 rounded-lg border border-gray-500 focus:border-purple-500 focus:outline-none"
                >
                  <option value={5}>Top 5</option>
                  <option value={10}>Top 10</option>
                  <option value={15}>Top 15</option>
                  <option value={20}>Top 20</option>
                  <option value={50}>Top 50</option>
                </select>
              </div>
              
              <div className="overflow-x-auto">
                <table className="w-full text-sm">
                  <thead>
                    <tr className="border-b border-gray-600">
                      <th className="text-left py-2 px-2">#</th>
                      <th className="text-right py-2 px-2">Note</th>
                      <th className="text-left py-2 px-2">Joueur</th>
                      <th className="text-left py-2 px-2">√âquipe</th>
                      <th className="text-left py-2 px-2">Profil</th>
                      <th className="text-right py-2 px-2">Minutes</th>
                      <th className="text-right py-2 px-2">Buts</th>
                      <th className="text-right py-2 px-2">Passes D.</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredPlayers
                      .sort((a, b) => (b.note || 0) - (a.note || 0))
                      .slice(0, topPlayersCount)
                      .map((player, index) => (
                        <tr 
                          key={index} 
                          className={`border-b border-gray-600/50 hover:bg-gray-600/30 transition ${
                            selectedPlayer?.Joueur === player.Joueur ? 'bg-purple-600/20' : ''
                          }`}
                        >
                          <td className="py-2 px-2 font-bold text-purple-400">{index + 1}</td>
                          <td className="py-2 px-2 text-right font-bold text-yellow-400">{(player.note || 0).toFixed(2)}</td>
                          <td className="py-2 px-2">
                            <button
                              onClick={() => setSelectedPlayer(player)}
                              className="font-medium text-left hover:text-purple-400 hover:underline transition w-full"
                            >
                              {player.Joueur}
                            </button>
                          </td>
                          <td className="py-2 px-2 text-gray-300">{player.√âquipe}</td>
                          <td className="py-2 px-2 text-gray-400 text-xs">{player['Profil_detecte'] || getPosteAgrege(player.Place)}</td>
                          <td className="py-2 px-2 text-right text-gray-300">{player['Minutes.jou√©es'] || 0}</td>
                          <td className="py-2 px-2 text-right text-green-400">
                            {(player['Buts.par.90.min'] || 0).toFixed(2)}
                          </td>
                          <td className="py-2 px-2 text-right text-blue-400">
                            {(player['Passes.d√©cisives.par.90.min'] || 0).toFixed(2)}
                          </td>
                        </tr>
                      ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>

        {showEvolution && evolutionStats.length > 1 && selectedPlayer && (
          <div className="bg-gray-800/90 backdrop-blur rounded-xl shadow-2xl p-6 border border-gray-700 mb-6">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold flex items-center gap-3">
                <TrendingUp size={24} className="text-green-400" />
                √âvolution de {selectedPlayer.Joueur} sur plusieurs saisons
                {comparePlayer && evolutionStatsCompare.length > 0 && (
                  <span className="text-purple-400"> vs {comparePlayer.Joueur}</span>
                )}
              </h2>
            </div>
            
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              {/* Graphique Note globale */}
              <div 
                className="bg-gray-700/50 rounded-lg p-4 cursor-pointer hover:bg-gray-700/70 transition active:bg-gray-700/80"
                onClick={() => setExpandedChart('note')}
                onTouchEnd={(e) => {
                  e.preventDefault();
                  setExpandedChart('note');
                }}
              >
                <h3 className="font-bold mb-3 text-center">Note globale (cliquer pour agrandir)</h3>
                <ResponsiveContainer width="100%" height={250}>
                  <LineChart 
                    margin={{ top: 40, right: 5, left: 0, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={8}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis 
                      stroke="#fff" 
                      fontSize={12} 
                      domain={(() => {
                        const allNotes = [...evolutionStats.map(s => s.note)];
                        if (comparePlayer && evolutionStatsCompare.length > 0) {
                          allNotes.push(...evolutionStatsCompare.map(s => s.note));
                        }
                        const maxNote = Math.max(...allNotes);
                        const minNote = Math.min(...allNotes);
                        
                        if (maxNote > 7.2) {
                          return [
                            Math.max(0, minNote - 0.3),
                            maxNote + 0.3
                          ];
                        } else {
                          return [
                            Math.min(minNote, 6.5),
                            Math.max(maxNote, 7.5)
                          ];
                        }
                      })()}
                      tickFormatter={(value) => value.toFixed(2)}
                    />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name, props) => {
                        return [value.toFixed(2), name];
                      }}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        // Cr√©er un tableau avec toutes les saisons possibles
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        // Mapper les donn√©es du joueur 1 sur toutes les saisons
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, note: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="note" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      stroke="url(#noteGradient)"
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        let color = '#ef4444';
                        if (value >= 6.8) color = '#22c55e';
                        else if (value >= 6) color = '#f59e0b';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill={color} 
                              fontSize={12} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={9} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={9} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, note: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="note" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        stroke="#7E57C2"
                        strokeDasharray="5 5"
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          let color = '#ef4444';
                          if (value >= 6.8) color = '#22c55e';
                          else if (value >= 6) color = '#f59e0b';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill={color} 
                                fontSize={12} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={9} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={9} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                    <defs>
                      <linearGradient id="noteGradient" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stopColor="#22c55e" />
                        <stop offset="50%" stopColor="#f59e0b" />
                        <stop offset="100%" stopColor="#ef4444" />
                      </linearGradient>
                    </defs>
                  </LineChart>
                </ResponsiveContainer>
              </div>

              {/* Graphique Buts */}
              <div 
                className="bg-gray-700/50 rounded-lg p-4 cursor-pointer hover:bg-gray-700/70 transition active:bg-gray-700/80"
                onClick={() => setExpandedChart('buts')}
                onTouchEnd={(e) => {
                  e.preventDefault();
                  setExpandedChart('buts');
                }}
              >
                <h3 className="font-bold mb-3 text-center">Buts (par 90 min) (cliquer pour agrandir)</h3>
                <ResponsiveContainer width="100%" height={250}>
                  <LineChart 
                    margin={{ top: 40, right: 5, left: 0, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={8}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis stroke="#fff" fontSize={12} />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name) => [value.toFixed(2), name]}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, buts: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="buts" 
                      stroke="#3F51B5" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill="#3F51B5" 
                              fontSize={12} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={9} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={9} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, buts: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="buts" 
                        stroke="#F48FB1" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill="#F48FB1" 
                                fontSize={12} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={9} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={9} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                  </LineChart>
                </ResponsiveContainer>
              </div>

              {/* Graphique Passes d√©cisives */}
              <div 
                className="bg-gray-700/50 rounded-lg p-4 cursor-pointer hover:bg-gray-700/70 transition active:bg-gray-700/80"
                onClick={() => setExpandedChart('passes')}
                onTouchEnd={(e) => {
                  e.preventDefault();
                  setExpandedChart('passes');
                }}
              >
                <h3 className="font-bold mb-3 text-center">Passes d√©cisives (par 90 min) (cliquer pour agrandir)</h3>
                <ResponsiveContainer width="100%" height={250}>
                  <LineChart 
                    margin={{ top: 40, right: 5, left: 0, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={8}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis stroke="#fff" fontSize={12} />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name) => [value.toFixed(2), name]}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, passesD: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="passesD" 
                      stroke="#3F51B5" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill="#3F51B5" 
                              fontSize={12} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={9} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={9} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, passesD: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="passesD" 
                        stroke="#F48FB1" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill="#F48FB1" 
                                fontSize={12} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={9} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={9} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                  </LineChart>
                </ResponsiveContainer>
              </div>
            </div>
          </div>
        )}

        {showRadarComparison && selectedPlayer && comparePlayer && (
          <div className="bg-gray-800/90 backdrop-blur rounded-xl shadow-2xl p-6 border border-gray-700 mb-6">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-2xl font-bold flex items-center gap-3">
                <Users size={24} className="text-orange-400" />
                Radar de comparaison : {selectedPlayer.Joueur} vs {comparePlayer.Joueur}
              </h2>
              <button
                onClick={downloadRadarComparison}
                className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-pink-600 to-pink-700 hover:from-pink-700 hover:to-pink-800 rounded-lg transition shadow-lg"
              >
                <Download size={16} />
                <span className="hidden sm:inline">T√©l√©charger</span>
              </button>
            </div>
            <canvas
              ref={radarComparisonRef}
              width={1000}
              height={1000}
              className="w-full h-auto rounded-lg"
            />
          </div>
        )}

        <div className="bg-gray-800/90 backdrop-blur rounded-xl shadow-2xl p-6 border border-gray-700">
          {selectedPlayer ? (
            <>
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-2xl font-bold">Radar Pizza - {selectedPlayer.Joueur}</h2>
                <button
                  onClick={downloadImage}
                  className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 rounded-lg transition shadow-lg"
                >
                  <Download size={16} />
                  <span className="hidden sm:inline">T√©l√©charger</span>
                  <span className="sm:hidden">PNG</span>
                </button>
              </div>
              <canvas
                ref={canvasRef}
                width={800}
                height={1400}
                className="w-full h-auto rounded-lg"
              />
            </>
          ) : (
            <div className="flex flex-col items-center justify-center py-20 text-center">
              <Upload size={64} className="text-gray-600 mb-4" />
              <p className="text-xl font-semibold text-gray-400 mb-2">Aucun joueur charg√©</p>
              <p className="text-sm text-gray-500">Importez un fichier CSV ou chargez depuis une URL pour commencer</p>
            </div>
          )}
        </div>

        <div className="mt-6 bg-gray-800/90 backdrop-blur rounded-xl p-6 border border-gray-700">
          <h3 className="font-bold mb-4 text-lg flex items-center gap-2">
            <Info size={16} />
            L√©gende des cat√©gories
          </h3>
          <div className="grid grid-cols-2 gap-4">
            {Object.entries(categoryColors).map(([cat, color]) => (
              <div key={cat} className="flex items-center gap-3 px-4 py-2 bg-gray-700/50 rounded-lg">
                <div className="w-5 h-5 rounded shadow-md flex-shrink-0" style={{ backgroundColor: color }} />
                <span className="text-sm font-medium">{cat}</span>
              </div>
            ))}
          </div>
        </div>
        
        {/* Modal agrandi pour les graphiques */}
        {expandedChart && (
          <div 
            className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4"
            onClick={() => setExpandedChart(null)}
            onTouchEnd={(e) => {
              if (e.target === e.currentTarget) {
                e.preventDefault();
                setExpandedChart(null);
              }
            }}
          >
            <div 
              className="bg-gray-800 rounded-xl p-6 max-w-6xl w-full max-h-[90vh] overflow-auto"
              onClick={(e) => e.stopPropagation()}
              onTouchEnd={(e) => e.stopPropagation()}
            >
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-xl font-bold">
                  {expandedChart === 'note' && comparePlayer && evolutionStatsCompare.length > 0 
                    ? `√âvolution de la Note : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
                    : expandedChart === 'note' 
                      ? `√âvolution de la Note de ${selectedPlayer.Joueur}`
                      : expandedChart === 'buts' && comparePlayer && evolutionStatsCompare.length > 0
                        ? `√âvolution des Buts : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
                        : expandedChart === 'buts'
                          ? `√âvolution des Buts de ${selectedPlayer.Joueur}`
                          : comparePlayer && evolutionStatsCompare.length > 0
                            ? `√âvolution des Passes d√©cisives : ${selectedPlayer.Joueur} vs ${comparePlayer.Joueur}`
                            : `√âvolution des Passes d√©cisives de ${selectedPlayer.Joueur}`
                  }
                </h3>
                <button
                  onClick={() => setExpandedChart(null)}
                  className="text-white hover:text-red-400 text-2xl font-bold px-3 py-1"
                >
                  ‚úï
                </button>
              </div>
              
              <ResponsiveContainer width="100%" height={500}>
                {expandedChart === 'note' && (
                  <LineChart 
                    margin={{ top: 40, right: 5, left: 0, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={10}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis 
                      stroke="#fff" 
                      fontSize={14} 
                      domain={(() => {
                        const allNotes = [...evolutionStats.map(s => s.note)];
                        if (comparePlayer && evolutionStatsCompare.length > 0) {
                          allNotes.push(...evolutionStatsCompare.map(s => s.note));
                        }
                        const maxNote = Math.max(...allNotes);
                        const minNote = Math.min(...allNotes);
                        
                        if (maxNote > 7.2) {
                          return [
                            Math.max(0, minNote - 0.3),
                            maxNote + 0.3
                          ];
                        } else {
                          return [
                            Math.min(minNote, 6.5),
                            Math.max(maxNote, 7.5)
                          ];
                        }
                      })()}
                      tickFormatter={(value) => value.toFixed(2)}
                    />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151', fontSize: '14px' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name) => {
                        return [value.toFixed(2), name];
                      }}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, note: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="note" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      stroke="#3F51B5"
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill="#3F51B5" 
                              fontSize={14} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={10} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={10} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, note: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="note" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        stroke="#F48FB1"
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill="#F48FB1" 
                                fontSize={14} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={10} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={10} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                    <defs>
                      <linearGradient id="noteGradient" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stopColor="#22c55e" />
                        <stop offset="50%" stopColor="#f59e0b" />
                        <stop offset="100%" stopColor="#ef4444" />
                      </linearGradient>
                    </defs>
                  </LineChart>
                )}
                
                {expandedChart === 'buts' && (
                  <LineChart 
                    margin={{ top: 40, right: 5, left: 0, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={10}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis stroke="#fff" fontSize={14} />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151', fontSize: '14px' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name) => [value.toFixed(2), name]}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, buts: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="buts" 
                      stroke="#3F51B5" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill="#3F51B5" 
                              fontSize={14} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={10} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={10} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, buts: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="buts" 
                        stroke="#F48FB1" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill="#F48FB1" 
                                fontSize={14} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={10} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={10} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                  </LineChart>
                )}
                
                {expandedChart === 'passes' && (
                  <LineChart 
                    margin={{ top: 40, right: 10, left: 10, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke="#444" />
                    <XAxis 
                      dataKey="saison"
                      stroke="#fff" 
                      fontSize={10}
                      type="category"
                      allowDuplicatedCategory={false}
                    />
                    <YAxis stroke="#fff" fontSize={14} />
                    <Tooltip 
                      contentStyle={{ backgroundColor: '#1f2937', border: '1px solid #374151', fontSize: '14px' }}
                      labelStyle={{ color: '#fff' }}
                      formatter={(value, name) => [value.toFixed(2), name]}
                    />
                    <Legend />
                    <Line 
                      data={(() => {
                        const allSeasons = new Set([
                          ...evolutionStats.map(s => s.saison),
                          ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                        ]);
                        const sortedSeasons = Array.from(allSeasons).sort();
                        
                        return sortedSeasons.map(saison => {
                          const data = evolutionStats.find(s => s.saison === saison);
                          return data || { saison, passesD: null };
                        });
                      })()}
                      type="monotone" 
                      dataKey="passesD" 
                      stroke="#3F51B5" 
                      strokeWidth={3} 
                      name={selectedPlayer.Joueur}
                      connectNulls={false}
                      label={({ value, index, x, y }) => {
                        if (!value) return null;
                        const allSeasons = (() => {
                          const seasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...(comparePlayer && evolutionStatsCompare.length > 0 ? evolutionStatsCompare.map(s => s.saison) : [])
                          ]);
                          return Array.from(seasons).sort();
                        })();
                        const saison = allSeasons[index];
                        const data = evolutionStats.find(s => s.saison === saison);
                        if (!data) return null;
                        
                        const minutes = data.minutes || 0;
                        const championnat = data.championnat || '';
                        
                        return (
                          <g>
                            <text 
                              x={x} 
                              y={y - 40} 
                              fill="#3F51B5" 
                              fontSize={14} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {value.toFixed(2)}
                            </text>
                            <text 
                              x={x} 
                              y={y - 28} 
                              fill="#9ca3af" 
                              fontSize={10} 
                              textAnchor="middle"
                            >
                              {`${minutes} min`}
                            </text>
                            <text 
                              x={x} 
                              y={y - 16} 
                              fill="#4b5563" 
                              fontSize={10} 
                              textAnchor="middle"
                              fontWeight="bold"
                            >
                              {championnat}
                            </text>
                          </g>
                        );
                      }}
                    />
                    {comparePlayer && evolutionStatsCompare.length > 0 && (
                      <Line 
                        data={(() => {
                          const allSeasons = new Set([
                            ...evolutionStats.map(s => s.saison),
                            ...evolutionStatsCompare.map(s => s.saison)
                          ]);
                          const sortedSeasons = Array.from(allSeasons).sort();
                          
                          return sortedSeasons.map(saison => {
                            const data = evolutionStatsCompare.find(s => s.saison === saison);
                            return data || { saison, passesD: null };
                          });
                        })()}
                        type="monotone" 
                        dataKey="passesD" 
                        stroke="#F48FB1" 
                        strokeWidth={3} 
                        name={comparePlayer.Joueur}
                        connectNulls={false}
                        label={({ value, index, x, y }) => {
                          if (!value) return null;
                          const allSeasons = (() => {
                            const seasons = new Set([
                              ...evolutionStats.map(s => s.saison),
                              ...evolutionStatsCompare.map(s => s.saison)
                            ]);
                            return Array.from(seasons).sort();
                          })();
                          const saison = allSeasons[index];
                          const data = evolutionStatsCompare.find(s => s.saison === saison);
                          if (!data) return null;
                          
                          const minutes = data.minutes || 0;
                          const championnat = data.championnat || '';
                          
                          return (
                            <g>
                              <text 
                                x={x} 
                                y={y + 20} 
                                fill="#F48FB1" 
                                fontSize={14} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {value.toFixed(2)}
                              </text>
                              <text 
                                x={x} 
                                y={y + 32} 
                                fill="#9ca3af" 
                                fontSize={10} 
                                textAnchor="middle"
                              >
                                {`${minutes} min`}
                              </text>
                              <text 
                                x={x} 
                                y={y + 44} 
                                fill="#4b5563" 
                                fontSize={10} 
                                textAnchor="middle"
                                fontWeight="bold"
                              >
                                {championnat}
                              </text>
                            </g>
                          );
                        }}
                      />
                    )}
                  </LineChart>
                )}
              </ResponsiveContainer>
              
              <div className="mt-4 text-center flex gap-4 justify-center">
                <button
                  onClick={downloadExpandedChart}
                  className="flex items-center gap-2 px-6 py-2 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 rounded-lg transition"
                >
                  <Download size={16} />
                  T√©l√©charger
                </button>
                <button
                  onClick={() => setExpandedChart(null)}
                  className="px-6 py-2 bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 rounded-lg transition"
                >
                  Fermer
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default FootballRadarApp;
